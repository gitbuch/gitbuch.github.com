<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Kapitel 8. Git automatisieren</title>
    <link rel="stylesheet" type="text/css" href="gitbuch.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.78.1" />
    <link rel="home" href="index.html" title="Git" />
    <link rel="up" href="index.html" title="Git" />
    <link rel="prev" href="ch07.html" title="Kapitel 7. Git auf dem Server" />
    <link rel="next" href="ch09.html" title="Kapitel 9. Zusammenspiel mit anderen Versionsverwaltungssystemen" />
    <meta xmlns="" name="language" content="de" />
    <script xmlns="" src="http://hyphenator.googlecode.com/svn/trunk/Hyphenator.js" type="text/javascript"></script>
    <script xmlns="" type="text/javascript">
        Hyphenator.run();
    </script>
  </head>
  <body class="hyphenate">
    <div xmlns="" class="toc">
<p><a href="index.html">Startseite</a></p>
<dl class="toc">
          <dt>
            <span class="preface">
              <a href="pr01.html">Vorwort</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.leser">1. An wen richtet sich dieses Buch?</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.struktur">2. Wie ist das Buch zu lesen?</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.konventionen">3. Konventionen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.install-git-repo">4. Installation und „das Git-Repository“</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.doku">5. Dokumentation und Hilfe</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.kontakt">6. Downloads und Kontakt</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.dank">7. Danksagungen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#chap.vorwort-2te-auflage">8. Vorwort zur 2. Auflage</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#chap.vorwort-cc-ausgabe">9. Vorwort zur CreativeCommons-Ausgabe</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch01.html">1. Einführung und erste Schritte</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch01.html#sec.begriffe">1.1. Grundbegriffe</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch01.html#sec.erste-schritte">1.2. Erste Schritte mit Git</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch01.html#chap.git-config">1.3. Git konfigurieren</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch02.html">2. Grundlagen</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch02.html#sec.grundlagen">2.1. Git-Kommandos</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch02.html#sec.objektmodell">2.2. Das Objektmodell</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch03.html">3. Praktische Versionsverwaltung</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.branches">3.1. Referenzen: Branches und Tags</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.undo">3.2. Versionen wiederherstellen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.merge">3.3. Branches zusammenführen: Merges</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.merge-conflicts">3.4. Merge-Konflikte lösen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.cherry-pick">3.5. Einzelne Commits übernehmen: Cherry-Pick</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.visualization">3.6. Visualisierung von Repositories</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.reflog">3.7. Reflog</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch04.html">4. Fortgeschrittene Konzepte</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.rebase">4.1. Commits verschieben – Rebase</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.rebase-i">4.2. Die Geschichte umschreiben – Interaktives Rebase</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.blame">4.3. Wer hat diese Änderungen gemacht? – git blame</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.ignore">4.4. Dateien ignorieren</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.stash">4.5. Veränderungen auslagern – git stash</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.notes">4.6. Commits annotieren – git notes</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.multi-root">4.7. Mehrere Root-Commits</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.bisect">4.8. Regressionen finden – git bisect</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch05.html">5. Verteiltes Git</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.verteilte_systeme">5.1. Wie funktioniert verteilte Versionsverwaltung?</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.clone">5.2. Repositories klonen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.git_fetch">5.3. Commits herunterladen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.hochladen">5.4. Commits hochladen: git push</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.remotes-check">5.5. Remotes untersuchen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.multi-remote">5.6. Verteilter Workflow mit mehreren Remotes</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.remotes-verwalten">5.7. Remotes verwalten</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.remote-tags">5.8. Tags austauschen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.patch-queue">5.9. Patches per E-Mail</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.dictator">5.10. Ein verteilter, hierarchischer Workflow</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.subprojects">5.11. Unterprojekte verwalten</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch06.html">6. Workflows</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch06.html#sec.workflows-user">6.1. Anwender</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch06.html#sec.branch-modell">6.2. Ein Branching-Modell</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch06.html#sec.releases-management">6.3. Releases-Management</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch07.html">7. Git auf dem Server</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch07.html#sec.server">7.1. Einen Git-Server hosten</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch07.html#sec.gitolite">7.2. Gitolite: Git einfach hosten</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch07.html#sec.git-daemon">7.3. Git-Daemon: Anonymer, lesender Zugriff</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch07.html#sec.gitweb">7.4. Gitweb: Das integrierte Web-Frontend</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch07.html#sec.cgit">7.5. CGit – CGI for Git</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch08.html">8. Git automatisieren</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch08.html#sec.attributes">8.1. Git-Attribute – Dateien gesondert behandeln</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch08.html#sec.hooks">8.2. Hooks</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch08.html#sec.scripting">8.3. Eigene Git-Kommandos schreiben</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch08.html#sec.filter-branch">8.4. Versionsgeschichte umschreiben</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch09.html">9. Zusammenspiel mit anderen Versionsverwaltungssystemen</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch09.html#sec.subversion">9.1. Subversion</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch09.html#sec.fast-import">9.2. Eigene Importer</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch10.html">10. Shell-Integration</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch10.html#sec.bash-integration">10.1. Git und die Bash</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch10.html#sec.zsh-integration">10.2. Git und die Z-Shell</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch11.html">11. Github</a>
            </span>
          </dt>
          <dt>
            <span class="appendix">
              <a href="apa.html">A. Installation</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="apa.html#linux">A.1. Linux</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="apa.html#sec.osx">A.2. Mac OS X</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="apa.html#sec.windows">A.3. Windows</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="appendix">
              <a href="apb.html">B. Struktur eines Repositorys</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="apb.html#sec.gc">B.1. Aufräumen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="apb.html#sec.gc-performance">B.2. Performance</a>
                </span>
              </dt>
            </dl>
          </dd>
        </dl></div>
    <div class="navheader">
      <table width="100%" summary="Navigation header">
        <tr>
          <td width="20%" align="left"><a accesskey="p" href="ch07.html">Zurück</a> </td>
          <th width="60%" align="center"> </th>
          <td width="20%" align="right"> <a accesskey="n" href="ch09.html">Weiter</a></td>
        </tr>
      </table>
      <hr />
    </div>
    <div class="chapter">
      <div class="titlepage">
        <div>
          <div>
            <h1 class="title"><a id="ch.scripting"></a>Kapitel 8. Git automatisieren</h1>
          </div>
        </div>
      </div>
      <p>In diesem Kapitel stellen wir fortgeschrittene Techniken zum
Automatisieren von Git vor. Im ersten Abschnitt über
<span class="emphasis"><em>Git-Attribute</em></span> zeigen wir Ihnen, wie Sie Git anweisen, bestimmte
Dateien gesondert zu behandeln, zum Beispiel um bei Grafiken ein
externes Diff-Kommando aufzurufen.</p>
      <p>Weiter geht es mit <span class="emphasis"><em>Hooks</em></span> – kleine Scripte, die beim Aufruf
verschiedener Git-Kommandos ausgeführt werden, beispielsweise um alle
Entwickler per E-Mail zu benachrichtigen, wenn neue Commits im
Repository eintreffen.</p>
      <p>Danach geben wir eine grundlegende Einführung ins Scripting mit
Git und zeigen Ihnen nützliche <span class="emphasis"><em>Plumbing-Kommandos</em></span>.</p>
      <p>Zum Abschluss stellen wir das mächtige <code class="literal">filter-branch</code>-Kommando
vor, mit dem Sie die Projektgeschichte im großen Stil umschreiben,
etwa um eine Datei mit einem Passwort aus <span class="emphasis"><em>allen</em></span> Commits zu
entfernen.</p>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="sec.attributes"></a>8.1. Git-Attribute – Dateien gesondert behandeln</h2>
            </div>
          </div>
        </div>
        <p>Über <span class="emphasis"><em>Git-Attribute</em></span> können Sie einzelnen oder einer Gruppe von
Dateien bestimmte Eigenschaften zuweisen, so dass Git sie besonders
behandelt; Beispiele wären, für bestimmte Dateien das Zeilenende zu
forcieren oder sie als binär zu markieren.</p>
        <p>Die Attribute schreiben Sie wahlweise in die Datei
<code class="literal">.gitattributes</code> oder <code class="literal">.git/info/attributes</code>.
Letztere gilt für ein Repository und wird nicht von Git verwaltet.
Eine Datei <code class="literal">.gitattributes</code> wird in der Regel eingecheckt, so
dass alle Entwickler diese Attribute verwenden. Außerdem können Sie in
Unterverzeichnissen weitere Attribut-Definitionen hinterlegen.</p>
        <p>Eine Zeile in dieser Datei hat das Format:</p>
        <pre class="screen">&lt;muster&gt; &lt;attrib1&gt; &lt;attrib2&gt; ...</pre>
        <p>Ein Beispiel:</p>
        <pre class="screen">*.eps   binary
*.tex   -text
*.c     filter=indent</pre>
        <p>In der Regel können Attribute gesetzt (z.B. <code class="literal">binary</code>),
aufgehoben (<code class="literal">-text</code>) oder auf einen Wert gesetzt werden
(<code class="literal">filter=indent</code>). Die Man-Page
<code class="literal">gitattributes(5)</code> beschreibt detailliert, wie Git die
Attribute interpretiert.</p>
        <p>Ein Projekt, das parallel auf Windows- und Unix-Rechnern entwickelt
wird, leidet darunter, dass die Entwickler verschiedene Konventionen
für Zeilenenden verwenden. Dies ist bedingt durch das Betriebssystem:
Windows-Systeme verwenden einen Carriage Return, gefolgt von einem
Line Feed (CRLF), während unixoide Systeme nur einen Line Feed (LF)
verwenden.</p>
        <p>Über geeignete Git-Attribute bestimmen Sie eine adäquate Policy – in
diesem Fall sind die Attribute <code class="literal">text</code> bzw.  <code class="literal">eol</code>
zuständig.  Das Attribut <code class="literal">text</code> bewirkt, dass die Zeilenenden
„normalisiert“ werden. Egal, ob der Editor eines Entwicklers
CRLF oder nur LF verwendet, Git wird im Blob nur die Version mit LF
speichern. Setzen Sie das Attribut auf <code class="literal">auto</code>, wird Git
diese Normalisierung nur ausführen, wenn die Datei auch wie Text
aussieht.</p>
        <p>Das Attribut <code class="literal">eol</code> hingegen bestimmt, was bei einem Checkout
passiert. Unabhängig von der Einstellung <code class="literal">core.eol</code> des Nutzers
können Sie so für einige Dateien z.B. CRLF vorgeben (weil das Format
dies benötigt).</p>
        <pre class="screen">*.txt   text
*.csv   eol=crlf</pre>
        <p>Mit diesen Attributen werden <code class="literal">.txt</code>-Dateien intern immer mit LF
gespeichert und bei Bedarf (plattform- bzw. nutzerabhängig) als CRLF
ausgecheckt. CSV-Dateien hingegen werden auf allen Plattformen mit
CRLF ausgecheckt. (Intern wird Git all diese Blobs mit einfachen
LF-Endungen speichern.)</p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.smudge-clean"></a>8.1.1. Filter: Smudge und Clean</h3>
              </div>
            </div>
          </div>
          <p>Git bietet über <span class="emphasis"><em>Filter</em></span> eine Möglichkeit, Dateien nach einem
Checkout zu „verschmutzen“ (<span class="emphasis"><em>smudge</em></span>) und vor einem
<code class="literal">git add</code> wieder zu „säubern“ (<span class="emphasis"><em>clean</em></span>).</p>
          <p>Die Filter erhalten keine Argumente, sondern nur den Inhalt des Blobs
auf Standard-In. Die Ausgabe des Programms wird als neuer Blob
verwendet.</p>
          <p>Für einen Filter müssen Sie jeweils ein Smudge- und ein Clean-Kommando
definieren. Fehlt eine der Definitionen oder ist der Filter
<code class="literal">cat</code>, wird der Blob unverändert übernommen.</p>
          <p>Welcher Filter für welche Art von Dateien verwendet wird, definieren
Sie über das Git-Attribut <code class="literal">filter</code>. Um beispielsweise C-Dateien
vor einem Commit automatisch richtig einzurücken, können Sie folgende
Filterdefinitionen verwenden (statt <code class="literal">&lt;indent&gt;</code> sind
beliebige andere Namen möglich):</p>
          <pre class="screen">$ <span class="strong"><strong>git config filter.&lt;indent&gt;.clean indent</strong></span>
$ <span class="strong"><strong>git config filter.&lt;indent&gt;.smudge cat</strong></span>
$ <span class="strong"><strong>echo '*.c filter=&lt;indent&gt;' &gt; .git/info/attributes</strong></span></pre>
          <p>Um eine C-Datei zu „säubern“, ruft Git nun automatisch das
Programm <code class="literal">indent</code> auf, das auf Standardsystemen installiert
sein sollte.<a href="#ftn.idm45240356161168" class="footnote" id="idm45240356161168"><sup class="footnote">[106]</sup></a></p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.smudge-clean-keywords"></a>8.1.2. Keywords in Dateien</h3>
              </div>
            </div>
          </div>
          <p>So lassen sich prinzipiell auch die bekannten Keyword-Expansionen
realisieren, so dass z.B. <code class="literal">$Version$</code> zu <code class="literal">$Version:
  v1.5.4-rc2$</code> wird.</p>
          <p>Sie definieren die Filter in Ihrer Konfiguration und statten dann
entsprechende Dateien mit diesem Git-Attribut aus. Das geht z.B. so:</p>
          <pre class="screen">$ <span class="strong"><strong>git config filter.version.smudge ~/bin/git-version.smudge</strong></span>
$ <span class="strong"><strong>git config filter.version.clean ~/bin/git-version.clean</strong></span>
$ <span class="strong"><strong>echo '* filter=version' &gt; .git/info/attributes</strong></span></pre>
          <p>Ein Filter, der das <code class="literal">$Version$</code>-Keyword ersetzt bzw. wieder
aufräumt, könnte als Perl-Einzeiler realisiert werden; zunächst der
Smudge-Filter:</p>
          <pre class="screen">#!/bin/sh
version=`git describe --tags`
exec perl -pe 's/$Version(:\s[^$]+)?$/$Version: '"$version"'$/g'</pre>
          <p>Und der Clean-Filter:</p>
          <pre class="screen">#!/usr/bin/perl -p
s/$Version: [^$]+$/$Version$/g</pre>
          <p>Wichtig ist, dass mehrmalige Anwendung eines solchen Filters keine
unkontrollierten Veränderungen in der Datei vornimmt. Ein doppelter
Aufruf von Smudge sollte durch einen einfachen Aufruf von Clean wieder
behoben werden können.</p>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.smudge-clean-dontuse"></a>Einschränkungen</h4>
                </div>
              </div>
            </div>
            <p>Das Konzept von Filtern in Git ist bewusst simpel gehalten und wird
auch in künftigen Versionen nicht erweitert werden. Die Filter
erhalten <span class="emphasis"><em>keine</em></span> Informationen über den Kontext, in dem sich Git
gerade befindet: Passiert ein Checkout? Ein Merge? Ein Diff? Sie
erhalten lediglich den Blob-Inhalt. Die Filter sollen also nur
<span class="emphasis"><em>kontextunabhängige</em></span> Manipulationen durchführen.</p>
            <p>Zum Zeitpunkt, da Smudge aufgerufen wird, ist der <code class="literal">HEAD</code>
möglicherweise noch nicht auf dem aktuellen Stand (der obige Filter
würde bei einem <code class="literal">git checkout</code> eine falsche Versionsnummer in
die Datei schreiben, da er <span class="emphasis"><em>vor</em></span> dem Versetzen des <code class="literal">HEAD</code>
aufgerufen wird). Die Filter eignen sich also nur bedingt zur
Keyword-Expansion.</p>
            <p>Das mag zwar Nutzer, die sich an dieses Feature in anderen
Versionskontrollsystemen gewöhnt haben, verärgern. Es gibt allerdings
keine guten Argumente, <span class="emphasis"><em>innerhalb</em></span> eines Versionskontrollsystems
eine solche Expansion durchzuführen. Die internen Mechanismen, die Git
verwendet, um zu überprüfen, ob Dateien verändert wurden, werden
lahmgelegt (da sie immer durch den Clean-Filter geschickt werden
müssen).  Außerdem kann man aufgrund der Struktur von Git-Repositories
einen Blob durch die Commits bzw. Trees hindurch
„verfolgen“, kann also bei Bedarf die Zugehörigkeit einer
Datei zu einem Commit immer an ihrem Inhalt erkennen.</p>
            <p>Eine Keyword-Expansion ist also nur <span class="emphasis"><em>außerhalb</em></span> von Git sinnvoll.
Dafür ist dann aber nicht Git zuständig, sondern ein entsprechendes
<code class="literal">Makefile</code>-Target oder ein Script. So kann beispielsweise ein
<code class="literal">make dist</code> alle Vorkommen von <code class="literal">VERSION</code> durch die
Ausgabe von <code class="literal">git describe --tags</code> ersetzen. Git wird die
Dateien als „geändert“ anzeigen. Sobald die Dateien verteilt
sind (z.B. als Tarball), kann mit <code class="literal">git reset --hard</code> wieder
aufgeräumt werden.</p>
            <p>Alternativ sorgt das Attribut <code class="literal">export-subst</code> dafür, dass eine
Expansion der Form <code class="literal">$Format:&lt;Pretty&gt;$</code> durchgeführt wird.
Dabei muss <code class="literal">&lt;Pretty&gt;</code> ein Format sein, das für <code class="literal">git log
  --pretty=format:&lt;Pretty&gt;</code> gültig ist, also z.B. <code class="literal">%h</code> für die
gekürzte Commit-Hash-Summe. Git expandiert diese Attribute nur, wenn
die Datei per <code class="literal">git archive</code>
(siehe <a class="xref" href="ch06.html#sec.release-create" title="6.3.2. Release erstellen">Abschnitt 6.3.2, „Release erstellen“</a>) verpackt wird.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.external-diff"></a>8.1.3. Eigene Diff-Programme</h3>
              </div>
            </div>
          </div>
          <p>Der interne Diff-Mechanismus von Git eignet sich sehr gut für alle
Arten von Plaintext. Er versagt aber bei Binärdateien – Git gibt
lediglich aus, ob sie sich unterscheiden oder nicht. Wenn Sie
allerdings ein Projekt haben, in dem Sie Binärdaten verwalten müssen,
wie z.B. PDF-, OpenOffice-Dokumente oder Bilder, dann ist es
sinnvoll, ein spezielles Programm zu definieren, das sinnvolle Diffs
dieser Dateien erstellt.</p>
          <p>So gibt es beispielsweise <code class="literal">antiword</code> und <code class="literal">pdftotext</code>, um
Word-Dokumente und PDFs nach Plaintext zu konvertieren. Für
OpenOffice-Formate gibt es analoge Scripte. Bei Bildern können Sie
Kommandos aus der ImageMagick-Suite verwenden (siehe auch das Beispiel
weiter unten). Wenn Sie statistische Daten verwalten, können Sie die
geänderten Datensets nebeneinander plotten. Je nach Beschaffenheit
der Daten gibt es meist adäquate Möglichkeiten, Veränderungen zu
visualisieren.</p>
          <p>Solche Konvertierungsprozesse sind natürlich verlustbehaftet: Sie
können diese Diff-Ausgabe nicht nutzen, um beispielsweise in einem
Merge-Konflikt sinnvoll Änderungen in den Dateien vorzunehmen. Aber um
einen schnellen Überblick zu erhalten, wer was geändert hat, reichen
solche Techniken allemal aus.</p>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.external-diff-parameters"></a>API für externe Diff-Programme</h4>
                </div>
              </div>
            </div>
            <p>Git bietet eine simple API für eigene Diff-Filter. Einem Diff-Filter
werden immer die folgenden sieben Argumente übergeben:</p>
            <div class="orderedlist">
              <ol class="orderedlist" type="1">
                <li class="listitem">
Pfad (Name der Datei im Git-Repository)
</li>
                <li class="listitem">
alte Version der Datei
</li>
                <li class="listitem">
alte SHA-1-ID des Blobs
</li>
                <li class="listitem">
alte Unix-Rechte
</li>
                <li class="listitem">
neue Version der Datei
</li>
                <li class="listitem">
neue SHA-1-ID des Blobs
</li>
                <li class="listitem">
neue Unix-Rechte
</li>
              </ol>
            </div>
            <p>Die Argumente 2 und 5 sind möglicherweise temporäre Dateien, die
gelöscht werden, sobald sich das Diff-Programm wieder beendet; Sie
müssen sich also nicht um das Aufräumen kümmern.</p>
            <p>Wenn eine der beiden Dateien nicht existiert (neu hinzugefügt oder
gelöscht), dann wird <code class="literal">/dev/null</code> als Dateiname übergeben. Der
entsprechende Blob ist dann <code class="literal">00000</code>…, auch in dem Fall,
dass eine Datei noch nicht als festes Objekt in der
Objektdatenbank liegt (also nur im Working Tree oder Index).  Diese
Fälle muss das Diff-Kommando entsprechend behandeln können.</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.diff-config"></a>Externe Diffs konfigurieren</h4>
                </div>
              </div>
            </div>
            <p>Es gibt zwei Möglichkeiten, ein externes Diff-Programm aufzurufen. Die
erste Methode ist temporär: Setzen Sie einfach vor dem Aufruf von
<code class="literal">git diff</code> die Umgebungsvariable <code class="literal">GIT_EXTERNAL_DIFF</code>
auf den Pfad zu Ihrem Programm:</p>
            <pre class="screen">$ <span class="strong"><strong>GIT_EXTERNAL_DIFF=&lt;/pfad/zum/diff-kommando&gt; git diff HEAD^</strong></span></pre>
            <p>Die andere Möglichkeit ist persistent, erfordert aber ein wenig
Konfiguration. Zunächst definieren Sie ein eigenes Diff-Kommando
<code class="literal">&lt;name&gt;</code>:</p>
            <pre class="screen">$ <span class="strong"><strong>git config diff.&lt;name&gt;.command &lt;/pfad/zum/diff-kommando&gt;</strong></span></pre>
            <p>Das Kommando muss mit den oben erwähnten sieben Argumenten umgehen
können. Nun müssen Sie über das Git-Attribut <code class="literal">diff</code> definieren,
welches Diff-Programm aufgerufen wird. Schreiben Sie dazu
z.B. folgende Zeilen in die Datei <code class="literal">.gitattributes</code>:</p>
            <pre class="screen">*.jpg diff=imgdiff
*.pdf diff=pdfdiff</pre>
            <p>Wenn Sie die Datei einchecken, müssen andere Nutzer auch entsprechende
Kommandos für <code class="literal">imgdiff</code> bzw. <code class="literal">pdfdiff</code> gesetzt haben,
sonst sehen sie die reguläre Ausgabe. Wollen Sie diese Einstellung nur
für ein Repository vorgeben, schreiben Sie diese Informationen nach
<code class="literal">.git/info/attributes</code>.</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.diff-immages"></a>Bilder vergleichen</h4>
                </div>
              </div>
            </div>
            <p>Ein häufiger Anwendungsfall sind Bilder: Was hat sich zwischen zwei
Versionen eines Bildes geändert? Das zu visualisieren, ist nicht immer
einfach. Das Tool <code class="literal">compare</code> aus der ImageMagick-Suite markiert
für Bilder gleicher Größe die Stellen, die sich geändert haben.  Auch
kann man die beiden Bilder hintereinander animieren und durch das
„Flackern“ erkennen, wo das Bild geändert wurde.</p>
            <p>Stattdessen wollen wir ein Programm, das die beiden Bilder
gegenüberstellt. Zwischen den beiden Bildern wird eine Art
„Differenz“ dargestellt: Alle Bereiche, in denen Änderungen
aufgetreten sind, werden aus dem <span class="emphasis"><em>neuen</em></span> Bild auf weißen
Untergrund kopiert. Das Diff zeigt also, welche Bereiche hinzugekommen
sind.</p>
            <p>Dafür speichern wir folgendes Script unter
<code class="literal">$HOME/bin/imgdiff</code>:<a href="#ftn.idm45240356091632" class="footnote" id="idm45240356091632"><sup class="footnote">[107]</sup></a></p>
            <pre class="screen">#!/bin/sh

OLD="$2"
NEW="$5"

# "xc:none" ist "Nichts", entspricht einem fehlenden Bild
[ "$OLD" = "/dev/null" ] &amp;&amp; OLD="xc:none"
[ "$NEW" = "/dev/null" ] &amp;&amp; NEW="xc:none"

exec convert "$OLD" "$NEW" -alpha off \
    \( -clone 0-1 -compose difference -composite -threshold 0 \) \
    \( -clone 1-2 -compose copy_opacity -composite \
       -compose over -background white -flatten \) \
    -delete 2 -swap 1,2 +append \
    -background white -flatten x:</pre>
            <p>Zuletzt müssen wir noch das Diff-Kommando konfigurieren und dessen
Verwendung durch einen Eintrag in der Datei
<code class="literal">.git/info/attributes</code> sicherstellen.</p>
            <pre class="screen">$ <span class="strong"><strong>git config diff.imgdiff.command ~/bin/imgdiff</strong></span>
$ <span class="strong"><strong>echo "*.gif diff=imgdiff" &gt; .git/info/attributes</strong></span></pre>
            <p>Als Beispiel verwenden wir die Ursprungsversionen des Tux.<a href="#ftn.idm45240356082944" class="footnote" id="idm45240356082944"><sup class="footnote">[108]</sup></a>
Zunächst fügen wir den schwarzweißen Tux ein:</p>
            <pre class="screen">$ <span class="strong"><strong>wget http://www.isc.tamu.edu/~lewing/linux/sit3-bw-tran.1.gif \</strong></span>
  <span class="strong"><strong>-Otux.gif</strong></span>
$ <span class="strong"><strong>git add tux.gif &amp;&amp; git commit -m "tux hinzugefügt"</strong></span></pre>
            <p>Im nächsten Commit wird er durch eine eingefärbte Version ersetzt:</p>
            <pre class="screen">$ wget http://www.isc.tamu.edu/~lewing/linux/sit3-bw<span class="strong"><strong>o</strong></span>-tran.1.gif \ 
  -Otux.gif
$ <span class="strong"><strong>git diff</strong></span></pre>
            <p>Die Ausgabe des Kommandos <code class="literal">git diff</code> ist ein Fenster mit
folgendem Inhalt: Links die alte, rechts die neue Version, und
in der Mitte eine Maske derjenigen Teile des neuen Bildes, die anders
als das alte sind.</p>
            <div class="figure">
              <a id="fig.tux-diff"></a>
              <p class="title">
                <strong>Abbildung 8.1. Die Ausgabe von <code class="literal">git diff</code> mit dem eigenen Diff-Programm <code class="literal">imgdiff</code></strong>
              </p>
              <div class="figure-contents">
                <div class="mediaobject">
                  <img src="bilder_ebook/tux-diff.png" width="486" alt="bilder_ebook/tux-diff.png" />
                </div>
              </div>
            </div>
            <br class="figure-break" />
            <p>Das Beispiel mit dem Tux inkl. Anleitung finden Sie auch in einem Repository
unter: <a class="ulink" href="https://github.com/gitbuch/tux-diff-demo" target="_top">https://github.com/gitbuch/tux-diff-demo</a>.</p>
          </div>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="sec.hooks"></a>8.2. Hooks</h2>
            </div>
          </div>
        </div>
        <p>Hooks bieten einen Mechanismus, in wichtige Git-Kommandos
„einzuhaken“ und eigene Aktionen auszuführen. In der Regel
sind Hooks daher kleine Shell-Scripte, um automatisierte Aufgaben zu
erfüllen, wie z.B. E-Mails zu versenden, sobald neue Commits
hochgeladen werden, oder vor einem Commit auf Whitespace-Fehler zu
überprüfen und ggf. eine Warnung auszugeben.</p>
        <p>Damit Hooks von Git ausgeführt werden, müssen sie im Verzeichnis
<code class="literal">hooks/</code> im Git-Verzeichnis liegen, also unter
<code class="literal">.git/hooks/</code> bzw. unter <code class="literal">hooks/</code> auf
oberster Ebene bei Bare Repositories. Zudem müssen sie ausführbar
sein.</p>
        <p>Git installiert bei einem <code class="literal">git init</code> automatisch Beispiel-Hooks, diese
tragen aber die Endung <code class="literal">&lt;hook&gt;.sample</code> und werden daher ohne das Zutun des Nutzers
(Umbenennung der Dateien) nicht ausgeführt.</p>
        <p>Einen mitgelieferten Hook aktivieren Sie also z.B. so:</p>
        <pre class="screen">$ <span class="strong"><strong>mv .git/hooks/commit-msg.sample .git/hooks/commit-msg</strong></span></pre>
        <p>Hooks kommen in zwei Klassen: solche, die lokal ausgeführt werden
(Commit-Nachrichten bzw. Patches überprüfen, Aktionen nach einem
Merge oder Checkout ausführen etc.), und solche, die
serverseitig ausgeführt werden, wenn Sie Änderungen per <code class="literal">git
  push</code> veröffentlichen.<a href="#ftn.idm45240356057536" class="footnote" id="idm45240356057536"><sup class="footnote">[109]</sup></a></p>
        <p>Hooks, deren Name mit <code class="literal">pre-</code> beginnt, können häufig dazu
benutzt werden, zu entscheiden, ob eine Aktion ausgeführt wird oder
nicht. Beendet sich ein <code class="literal">pre</code>-Hook nicht erfolgreich (d.h.
mit einem Exit-Status ungleich Null), wird die Aktion
abgebrochen. Eine technische Dokumentation der Funktionsweise finden
Sie in der Man-Page <code class="literal">githooks(5)</code>.</p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.hooks-commit"></a>8.2.1. Commits</h3>
              </div>
            </div>
          </div>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">pre-commit</code>
</span>
              </dt>
              <dd>
Wird aufgerufen, bevor die Commit-Nachricht abgefragt
wird. Beendet sich der Hook mit einem Wert ungleich Null, wird der
Commit-Vorgang abgebrochen. Der per Default installierte Hook
überprüft, ob eine neu hinzugefügte Datei Nicht-ASCII-Zeichen im
Dateinamen trägt, und ob in den geänderten Dateien Whitespace-Fehler vorhanden
sind. Mit der Option <code class="literal">-n</code> bzw.  <code class="literal">--no-verify</code> überspringt <code class="literal">git commit</code>
diesen Hook.
</dd>
              <dt>
                <span class="term">
<code class="literal">prepare-commit-msg</code>
</span>
              </dt>
              <dd>
Wird ausgeführt, direkt bevor die Nachricht in
einem Editor angezeigt wird. Erhält bis zu drei Parameter, von denen
der erste die Datei ist, in der die Commit-Nachricht gespeichert ist,
so dass sie editiert werden kann. Der Hook kann z.B. automatisiert
Zeilen hinzufügen. Ein Exit-Status ungleich Null bricht den
Commit-Vorgang ab. Dieser Hook kann allerdings nicht übersprungen
werden und sollte daher nicht die Funktionalität von <code class="literal">pre-commit</code>
duplizieren oder ersetzen.
</dd>
              <dt>
                <span class="term">
<code class="literal">commit-msg</code>
</span>
              </dt>
              <dd>
Wird ausgeführt, nachdem die Commit-Nachricht
eingegeben wurde. Das einzige Argument ist die Datei, in der die
Nachricht gespeichert ist, so dass sie modifiziert werden kann
(Normalisierung). Dieser Hook kann durch <code class="literal">-n</code> bzw. <code class="literal">--no-verify</code>
übersprungen werden; beendet er sich nicht erfolgreich, bricht der
Commit-Vorgang ab.
</dd>
              <dt>
                <span class="term">
<code class="literal">post-commit</code>
</span>
              </dt>
              <dd>
Wird aufgerufen, nachdem ein Commit erstellt wurde.
</dd>
            </dl>
          </div>
          <p>Diese Hooks agieren nur lokal und dienen dazu, bestimmte Richtlinien
bezüglich der Commits bzw. der Commit-Nachrichten durchzusetzen.
Besonders der <code class="literal">pre-commit</code>-Hook ist dabei hilfreich.  Zum
Beispiel zeigen manche Editoren nicht adäquat an, wenn am Ende der
Zeile Leerzeichen sind oder Leerzeilen Leerzeichen enthalten. Das ist
wiederum störend, wenn andere Entwickler neben regulären Änderungen
auch noch Whitespace aufräumen müssen. Hier hilft Git mit folgendem
Kommando:</p>
          <pre class="screen">$ <span class="strong"><strong>git diff --cached --check</strong></span>
hooks.tex:82: trailing whitespace.
<span class="strong"><strong>+</strong></span> auch noch Whitespace aufräumen müssen._</pre>
          <p>Die Option <code class="literal">--check</code> lässt <code class="literal">git diff</code> überprüfen, ob
solche Whitespace-Fehler vorliegen, und beendet sich nur erfolgreich,
wenn die Änderungen fehlerfrei sind. Schreiben Sie dieses Kommando in
Ihren <code class="literal">pre-commit</code>-Hook, werden Sie immer gewarnt, wenn Sie
Whitespace-Fehler einchecken wollen. Sind Sie ganz sicher, können Sie
den Hook einfach temporär per <code class="literal">git commit -n</code> aussetzen.</p>
          <p>Ganz analog können Sie auch für eine Scriptsprache Ihrer Wahl das
„Syntax überprüfen“-Kommando in diesem Hook speichern. So
zum Beispiel folgender Block für Perl-Scripte:</p>
          <pre class="screen">git diff --diff-filter=MA --cached --name-only |
while read file; do
    if [ -f $file ] &amp;&amp; [ $(head -n 1 $file) = "#!/usr/bin/perl" ]; then
        perl -c $file || exit 1
    fi
done
true</pre>
          <p>Die Namen aller im Index veränderten Dateien (Diff-Filter
<code class="literal">modified</code> und <code class="literal">added</code>, siehe auch
<a class="xref" href="ch08.html#sec.scripting-find-changes" title="8.3.4. Änderungen finden">Abschnitt 8.3.4, „Änderungen finden“</a>) werden
an eine Subshell weitergeleitet, die pro Datei überprüft, ob die erste
Zeile ein Perl-Script ist. Wenn ja, wird die Datei mit <code class="literal">perl
  -c</code> überprüft. Falls sich ein Syntaxfehler in der Datei befindet,
gibt das Kommando eine entsprechende Fehlermeldung aus, und das
<code class="literal">exit 1</code> beendet den Hook, so dass Git den Commit-Vorgang
abbricht, noch bevor ein Editor geöffnet wird, um die Commit-Nachricht
einzugeben.</p>
          <p>Das schließende <code class="literal">true</code> wird z.B. benötigt, wenn eine
Nicht-Perl-Datei editiert wurde: Dann schlägt das If-Konstrukt fehl,
die Shell gibt den Rückgabewert des letzten Kommandos wieder, und
obwohl es nichts zu bemängeln gibt, wird Git den Commit nicht
ausführen. Durch die Zeile <code class="literal">true</code> war der Hook erfolgreich,
wenn alle Durchläufe der <code class="literal">while</code>-Schleife erfolgreich waren.</p>
          <p>Der Hook kann natürlich vereinfacht werden, wenn man annimmt, dass
alle Perl-Dateien als <code class="literal">&lt;name&gt;.pl</code> vorliegen. Dann reicht
der folgende Code:</p>
          <pre class="screen">git ls-files -z -- '*.pl' | xargs -z -n 1 perl -c</pre>
          <p>Weil Sie im Zweifel nur die von Git verwalteten Dateien überprüfen
wollen, eignet sich hier ein <code class="literal">git ls-files</code> besser als ein
simples <code class="literal">ls</code>, denn das würde auch nicht getrackte Dateien, die
auf <code class="literal">.pl</code> enden, auflisten.</p>
          <p>Neben der Überprüfung der Syntax können Sie natürlich auch Programme
im Stil von Lint einsetzen, die den Quellcode auf
„unschöne“ oder nicht portable Konstrukte überprüfen.</p>
          <p>Solche Hooks sind äußerst sinnvoll, um nicht versehentlich
fehlerhaften Code einzuchecken. Sind Warnungen unangebracht, können
Sie den Hook <code class="literal">pre-commit</code> ja immer über die Option <code class="literal">-n</code>
beim Committen überspringen.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.hooks-server"></a>8.2.2. Serverseitig</h3>
              </div>
            </div>
          </div>
          <p>Die folgenden Hooks werden auf Empfängerseite von <code class="literal">git
  receive-pack</code> aufgerufen, nachdem der Nutzer im lokalen Repository
<code class="literal">git push</code> eingegeben hat.</p>
          <p>Für einen Push-Vorgang erstellt <code class="literal">git send-pack</code> auf der lokalen
Seite <span class="emphasis"><em>ein</em></span> Packfile (siehe auch <a class="xref" href="ch02.html#sec.od" title="2.2.3. Die Objektdatenbank">Abschnitt 2.2.3, „Die Objektdatenbank“</a>), das
von <code class="literal">git receive-pack</code> auf der Empfängerseite entgegengenommen
wird. Ein solches Packfile enthält die neuen Werte einer oder mehrerer
Referenzen sowie die Commits, die das Empfänger-Repository benötigt,
um die Versionsgeschichte komplett abzubilden. Welche Commits das
sind, handeln die beiden Seiten vorher aus (ähnlich einer
Merge-Basis).</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">pre-receive</code>
</span>
              </dt>
              <dd>
Der Hook wird einmal aufgerufen und erhält auf
Standard-Input eine Liste der geänderten Referenzen (Format
s.u.). Wenn der Hook sich nicht erfolgreich beendet, verweigert <code class="literal">git
receive-pack</code> die Annahme (der gesamte Push-Vorgang schlägt fehl).
</dd>
              <dt>
                <span class="term">
<code class="literal">update</code>
</span>
              </dt>
              <dd>
Wird einmal <span class="emphasis"><em>pro geänderter Referenz</em></span> aufgerufen und erhält
drei Argumente: den alten Stand der Referenz, den vorgeschlagenen
neuen sowie den Namen der Referenz. Beendet sich der Hook nicht
erfolgreich, wird das Update der einzelnen Referenz verweigert (im
Gegensatz zu <code class="literal">pre-receive</code>, wo nur einem ganzen Packfile zugestimmt
werden kann oder nicht).
</dd>
              <dt>
                <span class="term">
<code class="literal">post-receive</code>
</span>
              </dt>
              <dd>
Analog zu <code class="literal">pre-receive</code>, aber wird erst aufgerufen,
<span class="emphasis"><em>nachdem</em></span> die Referenzen geändert wurden (kann also keinen Einfluss
mehr nehmen, ob das Packfile angenommen wird oder nicht).
</dd>
              <dt>
                <span class="term">
<code class="literal">post-update</code>
</span>
              </dt>
              <dd>
Nachdem alle Referenzen geändert wurden, wird dieser
Hook einmal ausgeführt und erhält die Namen aller geänderten
Referenzen als Argumente. Der Hook bekommt aber nicht mitgeteilt, auf
welchem Stand die Referenzen vorher waren bzw.  jetzt sind. (Dafür
können Sie <code class="literal">post-receive</code> verwenden.) Ein typischer Anwendungsfall ist
ein Aufruf von <code class="literal">git update-server-info</code>, der nötig ist, wenn Sie ein
Repository per HTTP anbieten wollen.
</dd>
            </dl>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.hooks-receive-format"></a>Das Format der receive-Hooks</h4>
                </div>
              </div>
            </div>
            <p>Die Hooks <code class="literal">pre-receive</code> und <code class="literal">post-receive</code> erhalten
eine äquivalente Eingabe auf Standard-Input. Das Format ist das
folgende:</p>
            <pre class="screen">&lt;alte-sha1&gt; &lt;neue-sha1&gt; &lt;name-der-referenz&gt;</pre>
            <p>Das kann zum Beispiel so aussehen:</p>
            <pre class="screen">0000000...0000000 ca0e8cf...12b14dc refs/heads/newbranch
ca0e8cf...12b14dc 0000000...0000000 refs/heads/oldbranch
6618257...93afb8d 62dec1c...ac5373b refs/heads/master</pre>
            <p>Eine SHA-1-Summe aus lauter Nullen bedeutet „nicht
vorhanden“. Die erste Zeile beschreibt also eine Referenz, die
vorher nicht vorhanden war, während die zweite Zeile das Löschen einer
Referenz bedeutet. Die dritte Zeile stellt ein reguläres Update dar.</p>
            <p>Sie können die Referenzen bequem mit folgender Schleife einlesen:</p>
            <pre class="screen">while read old new ref; do
  # ...
done</pre>
            <p>In <code class="literal">old</code> und <code class="literal">new</code> sind dann die SHA-1-Summen
gespeichert, während <code class="literal">ref</code> den Namen der Referenz enthält. Ein
<code class="literal">git log $old..$new</code> würde alle neuen Commits auflisten. Die
Standard-Ausgabe wird an <code class="literal">git send-pack</code> auf der Seite, auf der
<code class="literal">git push</code> eingegeben wurde, weitergeleitet. Sie können also
mögliche Fehlermeldungen oder Reports unmittelbar an den Nutzer
weiterleiten.</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.hooks-email"></a>E-Mails verschicken</h4>
                </div>
              </div>
            </div>
            <p>Eine praktische Anwendung des <code class="literal">post-receive</code>-Hooks ist, E-Mails
zu verschicken, sobald neue Commits im Repository vorliegen. Das
können Sie natürlich selbst programmieren, allerdings gibt es schon
ein fertiges Script, das mit Git geliefert wird. Im
Quellverzeichnis von Git finden Sie es unter
<code class="literal">contrib/hooks/post-receive-email</code>, manche Distributionen,
z.B. Debian, installieren es auch zusammen mit Git nach
<code class="literal">/usr/share/doc/git/contrib/hooks/post-receive-email</code>.</p>
            <p>Sobald Sie den Hook in das Unterverzeichnis <code class="literal">hooks/</code> Ihres Bare
Repositorys kopiert und ausführbar gemacht haben, können Sie noch die
Konfiguration entsprechend anpassen:</p>
            <pre class="screen">$ <span class="strong"><strong>less config</strong></span>
...
[hooks]
  mailinglist = "Autor Eins &lt;autor1@example.com&gt;, autor2@example.com"
  envelopesender = "git@example.com"
  emailprefix = "[project] "</pre>
            <p>Damit wird für jeden Push-Vorgang pro Referenz eine Mail mit einer
Zusammenfassung der neuen Commits verschickt. Die Mail geht an alle
Empfänger, die in <code class="literal">hooks.mailinglist</code> definiert sind, und
stammt von <code class="literal">hooks.envelopesender</code>. Der
Subject-Zeile wird das <code class="literal">hooks.emailprefix</code> vorangestellt, so
dass die E-Mail leichter wegsortiert werden kann. Weitere Optionen
sind in den Kommentaren des Hooks dokumentiert.</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.hooks-update"></a>Der update-Hook</h4>
                </div>
              </div>
            </div>
            <p>Der <code class="literal">update</code>-Hook wird für jede Referenz einzeln aufgerufen.
Er eignet sich daher besonders gut, eine Art
„Zugriffsregelung“ auf bestimmte Branches zu implementieren.</p>
            <p>Tatsächlich wird der <code class="literal">update</code>-Hook zum Beispiel von Gitolite
(siehe <a class="xref" href="ch07.html#sec.gitolite" title="7.2. Gitolite: Git einfach hosten">Abschnitt 7.2, „Gitolite: Git einfach hosten“</a>) genutzt, um zu entscheiden, ob ein
Branch modifiziert werden darf oder nicht. Gitolite implementiert den
Hook als Perl-Script, das überprüft, ob die entsprechende Berechtigung
vorliegt, und sich entsprechend mit dem Rückgabewert Null oder nicht
Null beendet.</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.hooks-deploy"></a>Deployment über Hooks</h4>
                </div>
              </div>
            </div>
            <p>Git versteht sich als Versionsverwaltungssystem und weiß nichts von
Deployment-Prozessen. Über den Update-Hook können Sie allerdings –
z.B. für Web-Applikationen – ein einfaches Deployment-Verfahren
implementieren.</p>
            <p>Der folgende <code class="literal">update</code>-Hook wird, sofern der
<code class="literal">master</code>-Branch geändert wurde, die Änderungen auf
<code class="literal">/var/www/www.example.com</code> replizieren:</p>
            <pre class="screen">[ "$3" = "refs/heads/master" ] || exit 0
env GIT_WORK_TREE=/var/www/www.example.com git checkout -f</pre>
            <p>Sobald Sie also neue Commits per <code class="literal">git push</code> in den
Master-Branch des Servers hochladen, wird dieser Hook die Web-Präsenz
automatisch aktualisieren.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.hooks-am"></a>8.2.3. Patches anwenden</h3>
              </div>
            </div>
          </div>
          <p>Die folgenden Hooks werden jeweils von <code class="literal">git am</code> aufgerufen, wenn
ein oder mehrere Patches angewendet werden.</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">applypatch-msg</code>
</span>
              </dt>
              <dd>
Wird aufgerufen, bevor ein Patch angewendet
wird. Der Hook erhält als einzigen Parameter die Datei, in der die
Commit-Nachricht des Patches gespeichert ist.  Der Hook kann die
Nachricht bei Bedarf verändern. Ein Exit-Status ungleich Null
veranlasst <code class="literal">git am</code>, den Patch nicht anzunehmen.
</dd>
              <dt>
                <span class="term">
<code class="literal">pre-applypatch</code>
</span>
              </dt>
              <dd>
Wird aufgerufen, nachdem ein Patch angewendet
wurde, aber bevor die Änderung committet wird.  Ein Exit-Status
ungleich Null veranlasst <code class="literal">git am</code>, den Patch nicht anzunehmen.
</dd>
              <dt>
                <span class="term">
<code class="literal">post-applypatch</code>
</span>
              </dt>
              <dd>
Wird aufgerufen, nachdem ein Patch eingepflegt
wurde.
</dd>
            </dl>
          </div>
          <p>Die per Default installierten Hooks führen, sofern aktiviert, die
entsprechenden Commit-Hooks <code class="literal">commit-msg</code> und
<code class="literal">pre-commit</code> aus.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.hooks-misc"></a>8.2.4. Sonstige Hooks</h3>
              </div>
            </div>
          </div>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">pre-rebase</code>
</span>
              </dt>
              <dd>
Wird ausgeführt, bevor ein Rebase-Prozess
beginnt. Erhält als Argumente die Referenzen, die auch dem
Rebase-Kommando übergeben werden (also erhält der Hook z.B. bei dem
Kommando <code class="literal">git rebase master topic</code> die Argumente <code class="literal">master</code> und
<code class="literal">topic</code>). Anhand des Exit-Status entscheidet <code class="literal">git rebase</code>, ob der
Rebase-Vorgang ausgeführt wird oder nicht.
</dd>
            </dl>
          </div>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">pre-push</code>
</span>
              </dt>
              <dd>
Wird ausgeführt, bevor ein Push-Vorgang startet. Erhält auf
Standard-Input Zeilen der Form
<code class="literal">&lt;lokale-ref&gt;</code>␣<code class="literal">&lt;lokale-sha1&gt;</code>␣<code class="literal">&lt;remote-ref&gt;</code>␣<code class="literal">&lt;remote-sha1&gt;</code>.
Beendet sich der Hook nicht erfolgreich, so wird der Push-Vorgang
abgebrochen.
</dd>
              <dt>
                <span class="term">
<code class="literal">post-rewrite</code>
</span>
              </dt>
              <dd>
Wird von Kommandos aufgerufen, die Commits
umschreiben (momentan nur <code class="literal">git commit --amend</code> und <code class="literal">git rebase</code>).
Erhält auf Standard-Input eine Liste im Format
<code class="literal">&lt;alte-sha1&gt;</code>␣<code class="literal">&lt;neue-sha1&gt;</code>.
</dd>
              <dt>
                <span class="term">
<code class="literal">post-checkout</code>
</span>
              </dt>
              <dd>
Wird nach einem Checkout aufgerufen. Die ersten
beiden Parameter sind die alte und neue Referenz, auf die <code class="literal">HEAD</code>
zeigt. Der dritte Parameter ist ein Flag, das anzeigt, ob ein Branch
gewechselt wurde (<code class="literal">1</code>) oder einzelne Dateien ausgecheckt wurden (<code class="literal">0</code>).
</dd>
              <dt>
                <span class="term">
<code class="literal">post-merge</code>
</span>
              </dt>
              <dd>
Wird ausgeführt, wenn ein Merge erfolgreich beendet
wurde. Der Hook erhält als Argument eine <code class="literal">1</code>, wenn der Merge ein sog.
Squash-Merge war, also ein Merge, der keinen Commit erstellt, sondern
nur die Dateien im Working Tree bearbeitet hat.
</dd>
              <dt>
                <span class="term">
<code class="literal">pre-auto-gc</code>
</span>
              </dt>
              <dd>
Wird aufgerufen, bevor <code class="literal">git gc --auto</code> ausgeführt
wird.  Verhindert die Ausführung der automatischen Garbage-Collection,
wenn der Rückgabewert ungleich Null ist.
</dd>
            </dl>
          </div>
          <p>Die <code class="literal">post-checkout</code>- und <code class="literal">post-commit</code>-Hooks können Sie
gut verwenden, um Git „echte“ Dateizugriffsrechte
beizubringen. Ein Blob-Objekt spiegelt nämlich nicht genau den Inhalt
einer Datei und ihrer Zugriffsrechte wider. Stattdessen kennt Git nur
„ausführbar“ oder „nicht ausführbar“.<a href="#ftn.idm45240355906016" class="footnote" id="idm45240355906016"><sup class="footnote">[110]</sup></a></p>
          <p>Das im Git-Quellverzeichnis unter
<code class="literal">contrib/hooks/setgitperms.perl</code> abgelegte
Script bietet eine vorgefertigte Lösung, die Sie in die o.g. Hooks
integrieren können.  Das Script speichert die wirklichen
Zugriffsrechte in einer Datei <code class="literal">.gitmeta</code> ab. Wenn Sie das
Einlesen (Option <code class="literal">-r</code>) im <code class="literal">pre-commit</code>-Hook vornehmen
und die Hooks <code class="literal">post-checkout</code> und <code class="literal">post-merge</code> mit dem
Kommando zum Schreiben der Rechte ausstatten (Option <code class="literal">-w</code>),
dann sollten die Zugriffsrechte Ihrer Dateien nun persistent sein. Für
die genauen Kommandos siehe die Kommentare in der Datei.</p>
          <p>Die Zugriffsrechte sind natürlich nur zwischen Checkouts stabil – sofern Sie die Datei <code class="literal">.gitmeta</code> nicht einchecken und die
Benutzung der Hooks forcieren, bekommen Klone dieses Repositorys
natürlich nur die „einfachen“ Zugriffsrechte.</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="sec.scripting"></a>8.3. Eigene Git-Kommandos schreiben</h2>
            </div>
          </div>
        </div>
        <p>Git folgt mit seiner Einteilung in Subkommandos der Unix-Philosophie
„Ein Tool, ein Job“. Außerdem teilt es die Subkommandos in
zwei Kategorien: <span class="emphasis"><em>Porcelain</em></span> und <span class="emphasis"><em>Plumbing</em></span>.</p>
        <p>Porcelain bezeichnet das „gute Porzellan“, das für den
Endnutzer aus dem Schrank geholt wird: ein aufgeräumtes
Nutzerinterface und menschenlesbare Ausgaben. Die Plumbing-Kommandos
hingegen werden vor allem für die „Klempnerarbeit“ in
Scripten verwendet und haben eine maschinenlesbare Ausgabe (meist
zeilenweise mit eindeutigen Trennzeichen).</p>
        <p>Tatsächlich ist ein wesentlicher Teil der Porcelain-Kommandos als
Shell-Script realisiert. Sie verwenden intern die diversen
Plumbing-Kommandos, präsentieren aber nach außen hin ein
verständliches Interface. Die Kommandos <code class="literal">rebase</code>, <code class="literal">am</code>,
<code class="literal">bisect</code> und <code class="literal">stash</code> sind nur einige Beispiele.</p>
        <p>Es ist daher sinnvoll und einfach, selbst Shell-Scripte zu schreiben,
um häufig auftretende Aufgaben in Ihrem Arbeitsablauf zu
automatisieren. Das können zum Beispiel Scripte sein, die den
Release-Prozess der Software steuern, automatische Changelogs
erstellen oder andere auf das Projekt zugeschnittene Operationen.</p>
        <p>Ein eigenes Git-Kommando zu schreiben, ist denkbar einfach: Sie müssen
lediglich eine ausführbare Datei in einem Verzeichnis Ihres
<code class="literal">$PATH</code> ablegen (also z.B. in
<code class="literal">~/bin</code>), dessen Name mit <code class="literal">git-</code>
beginnt. Wenn Sie <code class="literal">git &lt;kommando&gt;</code> eingeben und
<code class="literal">&lt;kommando&gt;</code> ist weder ein Alias noch ein bekanntes Kommando,
dann versucht Git einfach, <code class="literal">git-&lt;kommando&gt;</code> auszuführen.</p>
        <div class="tip" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Tipp</h3>
          <p>Auch wenn Sie prinzipiell Scripte in einer beliebigen Sprache
schreiben können, empfehlen wir Ihnen die Verwendung von
Shell-Scripten: Nicht nur sind sie für Außenstehende leichter
verständlich, vor allem aber sind die typischen Operationen, mit denen
man Git-Kommandos kombiniert – Programme aufrufen, Ausgabeum- bzw.
-weiterleitung – mit der Shell „intuitiv“ machbar und bedürfen
keiner umständlichen Konstrukte, wie z.B. in Perl mit <code class="literal">qx()</code> oder in
Python mit <code class="literal">os.popen()</code>.</p>
          <p>Wenn Sie Shell-Scripte schreiben, achten Sie bitte auf
POSIX-Kompatibilität!<a href="#ftn.idm45240355879264" class="footnote" id="idm45240355879264"><sup class="footnote">[111]</sup></a>
Dazu gehört insbesondere, keine „Bashismen“ wie <code class="literal">[[ ... ]]</code> zu
verwenden (die POSIX-Entsprechung lautet <code class="literal">[ ... ]</code>). Wenn Ihr Script
nicht auch problemlos mit der Dash<a href="#ftn.idm45240355876160" class="footnote" id="idm45240355876160"><sup class="footnote">[112]</sup></a>  läuft, sollten Sie die verwendete Shell explizit in der
Shebang-Zeile angeben, z.B. via <code class="literal">#!/bin/bash</code>.</p>
        </div>
        <p>Sämtliche im folgenden Abschnitt vorgestellten Scripte finden Sie auch
online, in der Scriptsammlung für dieses Buch.<a href="#ftn.idm45240355872176" class="footnote" id="idm45240355872176"><sup class="footnote">[113]</sup></a></p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.scripting-init"></a>8.3.1. Initialisierung</h3>
              </div>
            </div>
          </div>
          <p>Typischerweise wollen Sie sicherstellen, dass Ihr Script in einem
Repository ausgeführt wird. Für notwendige Initialisierungsaufgaben
bietet Git das <code class="literal">git-sh-setup</code> an. Dieses Shell-Script sollten
Sie direkt nach der Shebang-Zeile per <code class="literal">.</code> einbinden (in
interaktiven Shells bekannt als <code class="literal">source</code>):</p>
          <pre class="screen">#!/bin/sh

. $(git --exec-path)/git-sh-setup</pre>
          <p>Sofern Git kein Repository entdecken kann, bricht
<code class="literal">git-sh-setup</code> ab. Außerdem bricht das Script ab, wenn es nicht
auf oberster Ebene in einem Repository ausgeführt wird. Ihr Script
kommt dadurch nicht zur Ausführung, und es wird eine entsprechende
Fehlermeldung ausgegeben. Dieses Verhalten können Sie umgehen, indem
Sie vor dem Aufruf die Variable <code class="literal">NONGIT_OK</code> bzw.
<code class="literal">SUBDIRECTORY_OK</code> setzen.</p>
          <p>Neben diesem Initialisierungsmechanismus stehen einige Funktionen
bereit, die häufig auftretende Aufgaben erledigen.  Nachfolgend eine
Übersicht über die wichtigsten:</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">cd_to_toplevel</code>
</span>
              </dt>
              <dd>
Wechselt auf die oberste Ebene des Git-Repositorys.
</dd>
              <dt>
                <span class="term">
<code class="literal">say</code>
</span>
              </dt>
              <dd>
Gibt die Argumente aus, es sei denn, <code class="literal">GIT_QUIET</code> ist gesetzt.
</dd>
              <dt>
                <span class="term">
<code class="literal">git_editor</code>
</span>
              </dt>
              <dd>
Öffnet den für Git eingestellten Editor auf den
angegebenen Dateien. Es ist besser, diese Funktion zu verwenden als
„blind“ <code class="literal">$EDITOR</code>. Git verwendet dies auch als Fallback.
</dd>
              <dt>
                <span class="term">
<code class="literal">git_pager</code>
</span>
              </dt>
              <dd>
Öffnet analog den für Git definierten Pager.
</dd>
              <dt>
                <span class="term">
<code class="literal">require_work_tree</code>
</span>
              </dt>
              <dd>
Die Funktion bricht mit einer Fehlermeldung ab,
wenn es keinen Working Tree zum Repository gibt – das ist bei Bare
Repositories der Fall. Sie sollten diese Funktion also
sicherheitshalber aufrufen, wenn Sie auf Dateien aus dem Working Tree
zugreifen wollen.
</dd>
            </dl>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.scripting-pos"></a>8.3.2. Position im Repository</h3>
              </div>
            </div>
          </div>
          <p>In Scripten werden Sie häufig die Information benötigen, aus welchem
Verzeichnis das Script aufgerufen wurde. Dafür bietet das Git-Kommando
<code class="literal">rev-parse</code> einige Optionen. Das folgende Script, abgelegt
unter <code class="literal">~/bin/git-whereami</code>, verdeutlicht, wie man
sich innerhalb eines Repositorys „zurechtfinden“ kann.</p>
          <pre class="screen">#!/bin/sh

SUBDIRECTORY_OK=Yes
. $(git --exec-path)/git-sh-setup

gitdir="$(git rev-parse --git-dir)"
absolute="$(git rev-parse --show-toplevel)"
relative="$(git rev-parse --show-cdup)"
prefix="$(git rev-parse --show-prefix)"

echo "gitdir    absolute    relative    prefix"
echo "$gitdir   $absolute   $relative   $prefix"</pre>
          <p>Die Ausgabe sieht wie folgt aus:</p>
          <pre class="screen">$ <span class="strong"><strong>git whereami</strong></span>
gitdir          absolute    relative    prefix
.git            /tmp/repo
$ <span class="strong"><strong>cd ganz/tief</strong></span>
$ <span class="strong"><strong>git whereami</strong></span>
gitdir          absolute    relative    prefix
/tmp/repo/.git  /tmp/repo   ../../      ganz/tief/</pre>
          <p>Besonders wichtig ist das Präfix, das Sie per <code class="literal">--show-prefix</code>
erhalten. Wenn Ihr Kommando Dateinamen entgegennimmt und Sie die
Blobs, denen sie entsprechen, in der Objektdatenbank finden wollen,
müssen Sie dieses Präfix vor den Dateinamen setzen. Wenn Sie sich
im Verzeichnis <code class="literal">ganz/tief</code> befinden und dem Script den
Dateinamen <code class="literal">README</code> übergeben, dann findet es den
entsprechenden Blob im aktuellen Tree via <code class="literal">ganz/tief/README</code>.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.scripting-rev-list"></a>8.3.3. Referenzen auflisten: rev-list</h3>
              </div>
            </div>
          </div>
          <p>Herzstück der Plumbing-Kommandos ist <code class="literal">git rev-list</code>
(<span class="emphasis"><em>revision list</em></span>). Seine Grundfunktion besteht darin, ein oder
mehrere Referenzen auf die SHA-1-Summe(n) aufzulösen, denen sie
entsprechen.</p>
          <p>Mit einem <code class="literal">git log &lt;ref1&gt;..&lt;ref2&gt;</code> zeigen Sie die
Commit-Nachrichten von <code class="literal">&lt;ref1&gt;</code> (exklusive) bis
<code class="literal">&lt;ref2&gt;</code> (inklusive) an. Das Kommando <code class="literal">git
  rev-list</code> löst diese Referenz auf die einzelnen Commits auf, die
davon betroffen sind, und gibt sie Zeile für Zeile aus:</p>
          <pre class="screen">$ <span class="strong"><strong>git rev-list master..topic</strong></span>
f4a6a973e38f9fac4b421181402be229786dbee9
bb8d8c12a4c9e769576f8ddeacb6eb4eedfa3751
c7c331668f544ac53de01bc2d5f5024dda7af283</pre>
          <p>Ein Script, das auf einem oder mehreren Commits operiert, kann also
Angaben, wie andere Git-Kommandos sie auch verstehen, einfach an
<code class="literal">rev-list</code> weiterleiten. Schon kann Ihr Script auch mit
komplizierten Ausdrücken umgehen.</p>
          <p>Das Kommando können Sie beispielsweise nutzen, um zu überprüfen, ob
ein Fast-Forward von einem Branch auf einen anderen möglich ist. Ein
Fast-Forward von <code class="literal">&lt;ref1&gt;</code> auf <code class="literal">&lt;ref2&gt;</code> ist genau dann
möglich, wenn Git im Commit-Graphen von <code class="literal">&lt;ref2&gt;</code> aus den Commit, den
<code class="literal">&lt;ref1&gt;</code> markiert, erreichen kann. Oder anders ausgedrückt: Es
gibt keinen von <code class="literal">&lt;ref1&gt;</code> erreichbaren Commit, der nicht
auch von <code class="literal">&lt;ref2&gt;</code> erreichbar wäre.</p>
          <pre class="screen">#!/bin/sh

SUBDIRECTORY_OK=Yes
. $(git --exec-path)/git-sh-setup

[ $# -eq 2 ] || { echo "usage: $(basename $0) &lt;ref1&gt; &lt;ref2&gt;"; exit 1; }

for i in $1 $2
do
    if ! git rev-parse --verify $i &gt;| /dev/null 2&gt;&amp;1 ; then
        echo "Ref:'$i' existiert nicht!" &amp;&amp; exit 1
    fi
done

one_two=$(git rev-list $1..$2)
two_one=$(git rev-list $2..$1)

[ $(git rev-parse $1) = $(git rev-parse $2) ] \
&amp;&amp; echo "$1 und $2 zeigen auf denselben Commit!" &amp;&amp; exit 2

[ -n "$one_two" ] &amp;&amp; [ -z "$two_one" ] \
&amp;&amp; echo "FF von $1 nach $2 möglich!" &amp;&amp; exit 0
[ -n "$two_one" ] &amp;&amp; [ -z "$one_two" ] \
&amp;&amp; echo "FF von $2 nach $1 möglich!" &amp;&amp; exit 0

echo "FF nicht möglich! $1 und $2 sind divergiert!" &amp;&amp; exit 3</pre>
          <p>Die Aufrufe von <code class="literal">rev-parse</code> in der For-Schleife prüfen, dass es
sich bei den Argumenten um Referenzen handelt, die Git auf einen
Commit (oder ein anderes Objekt der Datenbank) auflösen kann – schlägt das fehl, bricht das Script mit einer Fehlermeldung ab.</p>
          <p>Die Ausgabe des Scripts könnte so aussehen:</p>
          <pre class="screen">$ <span class="strong"><strong>git check-ff topic master</strong></span>
FF von master nach topic möglich!</pre>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Für einfache Scripte, die nur eine begrenzte Zahl an Optionen und
Argumenten erwarten, reicht eine simple Auswertung dieser, wie in dem
obigen Script, völlig aus. Sofern Sie jedoch ein komplexeres Projekt
planen, bietet sich der sog.  <span class="emphasis"><em>Getopt-Modus</em></span> von <code class="literal">git rev-parse</code>
an. Dieser erlaubt die Syntaxanalyse von Kommandozeilen-Optionen,
bietet also eine ähnliche Funktionalität wie die C-Bibliothek
<code class="literal">getopt</code>. Für Details siehe die Man-Page <code class="literal">git-rev-parse(1)</code>, Abschnitt
„Parseopt“.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.scripting-find-changes"></a>8.3.4. Änderungen finden</h3>
              </div>
            </div>
          </div>
          <p><code class="literal">git diff</code> und <code class="literal">git log</code> weisen Sie durch
die Option <code class="literal">--name-status</code> an, Informationen
über die Dateien, die ein Commit geändert hat, anzuzeigen:</p>
          <pre class="screen">$ <span class="strong"><strong>git log -1 --name-status 8c8674fc9</strong></span>
commit 8c8674fc954d8c4bc46f303a141f510ecf264fcd
...
M       git-pull.sh
M       t/t5520-pull.sh</pre>
          <p>Jedem Namen wird eines von fünf Flags<a href="#ftn.idm45240355806064" class="footnote" id="idm45240355806064"><sup class="footnote">[114]</sup></a>  vorangestellt, die in der nachfolgenden Liste
aufgeführt sind:</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">A</code> (<span class="emphasis"><em>added</em></span>)
</span>
              </dt>
              <dd>
Datei wurde hinzugefügt
</dd>
              <dt>
                <span class="term">
<code class="literal">D</code> (<span class="emphasis"><em>deleted</em></span>)
</span>
              </dt>
              <dd>
Datei wurde gelöscht
</dd>
              <dt>
                <span class="term">
<code class="literal">M</code> (<span class="emphasis"><em>modified</em></span>)
</span>
              </dt>
              <dd>
Datei wurde geändert
</dd>
              <dt>
                <span class="term">
<code class="literal">C</code> (<span class="emphasis"><em>copied</em></span>)
</span>
              </dt>
              <dd>
Datei wurde kopiert
</dd>
              <dt>
                <span class="term">
<code class="literal">R</code> (<span class="emphasis"><em>renamed</em></span>)
</span>
              </dt>
              <dd>
Datei wurde umbenannt
</dd>
            </dl>
          </div>
          <p>Den Flags <code class="literal">C</code> und <code class="literal">R</code> wird eine dreistellige Zahl
nachgestellt, die den prozentualen Anteil angibt, der gleich geblieben
ist. Wenn Sie eine Datei duplizieren, entspricht das also der
Ausgabe <code class="literal">C100</code>. Eine Datei, die im gleichen Commit per
<code class="literal">git mv</code> umbenannt und ein wenig abgeändert wird, könnte als
<code class="literal">R094</code> auftauchen – eine 94%-ige Umbenennung.</p>
          <pre class="screen">$ <span class="strong"><strong>git log -1 --name-status 0ecace728f</strong></span>
...
M       Makefile
R094    merge-index.c   builtin-merge-index.c
M       builtin.h
M       git.c</pre>
          <p>Sie können anhand dieser Flags über sog. Diff-Filter nach Commits
suchen, die eine bestimmte Datei geändert haben. Wollen Sie zum
Beispiel herausfinden, wer eine Datei wann hinzugefügt hat, dann
verwenden Sie das folgende Kommando:</p>
          <pre class="screen">$ <span class="strong"><strong>git log --pretty=format:'added by %an %ar' --diff-filter=A -- cache.h</strong></span>
added by Linus Torvalds 6 years ago</pre>
          <p>Sie können einem Diff-Filter mehrere Flags direkt hintereinander
angeben. Die Frage „Wer hat maßgeblich an dieser Datei
gearbeitet?“ lässt sich häufig dadurch beantworten, wessen
Commits diese Datei am meisten modifiziert haben. Das kann man zum
Beispiel so herausfinden:</p>
          <pre class="screen">$ <span class="strong"><strong>git log --pretty=format:%an --diff-filter=M -- cache.h | \</strong></span>
  <span class="strong"><strong>sort | uniq -c | sort -rn | head -n 5</strong></span>
    187 Junio C Hamano
    100 Linus Torvalds
     27 Johannes Schindelin
     26 Shawn O. Pearce
     24 Jeff King</pre>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.od-explore"></a>8.3.5. Die Objektdatenbank und rev-parse</h3>
              </div>
            </div>
          </div>
          <p>Das Git-Kommando <code class="literal">rev-parse</code> (<span class="emphasis"><em>revision parse</em></span>) ist ein
extrem flexibles Tool, dessen Aufgabe es unter anderem ist, Ausdrücke,
die Commits oder andere Objekte der Objektdatenbank beschreiben, in
deren komplette SHA-1-Summe zu übersetzen.  So verwandelt das Kommando
beispielsweise abgekürzte SHA-1-Summen in die eindeutige
40-Zeichen-Variante:</p>
          <pre class="screen">$ <span class="strong"><strong>git rev-parse --verify be1ca37e5</strong></span>
be1ca37e540973bb1bc9b7cf5507f9f8d6bce415</pre>
          <p>Die Option <code class="literal">--verify</code> wird übergeben, damit Git eine
entsprechende Fehlermeldung ausgibt, wenn die übergebene Referenz
keine gültige ist.</p>
          <p>Das Kommando kann aber auch mit der Option <code class="literal">--short</code> eine
SHA-1-Summe abkürzen. Standard sind sieben Zeichen:</p>
          <pre class="screen">$ <span class="strong"><strong>git rev-parse --verify --short be1ca37e540973bb1bc9b7cf5507f9f8d6bce415</strong></span>
be1ca37</pre>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Wenn Sie den <span class="emphasis"><em>Namen</em></span> des Branches herausfinden wollen, der gerade
ausgecheckt ist (im Gegensatz zur Commit-ID), verwenden Sie <code class="literal">git
rev-parse --symbolic-full-name HEAD</code>.</p>
          </div>
          <p>Doch <code class="literal">rev-parse</code> (und damit auch alle anderen Git-Kommandos,
die Argumente als Referenzen entgegennehmen) unterstützt noch weitere
Möglichkeiten, Objekte zu referenzieren.</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">&lt;sha1&gt;^{&lt;typ&gt;}</code>
</span>
              </dt>
              <dd>
                <p class="simpara">
Folgt der Referenz <code class="literal">&lt;sha1&gt;</code> und löst sie auf
ein Objekt vom Typ <code class="literal">&lt;typ&gt;</code> auf. So können Sie zu einem Commit
<code class="literal">&lt;commit&gt;</code> durch Angabe von <code class="literal">&lt;commit&gt;^{tree}</code> den entsprechenden
Tree finden.  Wenn Sie keinen expliziten Typ angeben, wird die
Referenz so lange aufgelöst, bis Git ein Objekt findet, das kein Tag
ist (das ist besonders praktisch, wenn man die Entsprechung zu einem
Tag finden will).
</p>
                <p class="simpara">Viele Git-Kommandos arbeiten nicht auf einem Commit, sondern auf den
Trees, die referenziert werden (z.B. das Kommando <code class="literal">git diff</code>, das ja
Dateien, also Tree-Einträge, vergleicht). In der Man-Page werden diese
Argumente <span class="emphasis"><em>tree-ish</em></span> („baumartig“) genannt. Git erwartet also
beliebige Referenzen, die sich auf einen Tree auflösen lassen, mit dem
das Kommando dann weiter arbeitet.</p>
              </dd>
              <dt>
                <span class="term">
<code class="literal">&lt;tree-ish&gt;:&lt;pfad&gt;</code>
</span>
              </dt>
              <dd>
Löst den Pfad <code class="literal">&lt;pfad&gt;</code> auf den entsprechend
referenzierten Tree oder Blob auf (entspricht einem Verzeichnis
bzw. einer Datei). Dabei wird das referenzierte Objekt aus
<code class="literal">&lt;tree-ish&gt;</code> extrahiert, was also ein Tag, ein Commit oder ein Tree
sein kann.
</dd>
            </dl>
          </div>
          <p>Das folgende Beispiel illustriert die Funktionsweise dieser speziellen
Syntax: Das erste Kommando extrahiert die SHA-1-ID des Trees, der
durch <code class="literal">HEAD</code> referenziert wird. Das zweite Kommando extrahiert
die SHA-1-ID des Blobs, der der Datei <code class="literal">README</code> auf oberster
Ebene des Git-Repositorys entspricht. Das dritte Kommando verifiziert
anschließend, dass dies wirklich ein Blob ist.</p>
          <pre class="screen">$ <span class="strong"><strong>git rev-parse 'HEAD^{tree}'</strong></span>
89f156b00f35fe5c92ac75c9ccf51f043fe65dd9
$ <span class="strong"><strong>git rev-parse 89f156b00f:README</strong></span>
67cfeb2016b24df1cb406c18145efd399f6a1792
$ <span class="strong"><strong>git cat-file -t 67cfeb2016b</strong></span>
blob</pre>
          <p>Ein <code class="literal">git show 67cfeb2016b</code> würde nun den tatsächlichen Inhalt
des Blobs anzeigen. Durch Umleitung mit <code class="literal">&gt;</code> können Sie so den
Blob als Datei auf das Dateisystem extrahieren.</p>
          <p>Das folgende Script findet zunächst die Commit-ID des Commits, der
zuletzt eine bestimmte Datei modifiziert (die Datei wird als erstes
Argument, also <code class="literal">$1</code>, übergeben).  Dann extrahiert das Script
die Datei (mit vorangestelltem Präfix, s.o.) aus dem
<span class="emphasis"><em>Vorgänger</em></span> des Commits (<code class="literal">$ref^</code>), der die Datei
zuletzt verändert hat, und speichert dies in einer temporären Datei.</p>
          <p>Schließlich wird Vim im Diff-Modus auf der Datei aufgerufen und
anschließend die Datei gelöscht.</p>
          <pre class="screen">#!/bin/sh

SUBDIRECTORY_OK=Yes
. $(git --exec-path)/git-sh-setup

[ -z "$1" ] &amp;&amp; echo "usage: $(basename $0) &lt;file&gt;" &amp;&amp; exit 1
ref="$(git log --pretty=format:%H --diff-filter=M -1 -- $1)"
git rev-parse --verify $ref &gt;/dev/null || exit 1

prefix="$(git rev-parse --show-prefix)"
temp="$(mktemp .diff.$ref.XXXXXX)"
git show $ref^:$prefix$1 &gt; $temp

vim -f -d $temp $1
rm $temp</pre>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Um besonders viele Referenzen per <code class="literal">rev-parse</code> aufzulösen, sollten Sie dies in <span class="emphasis"><em>einem</em></span> Programmaufruf tun: <code class="literal">rev-parse</code> gibt für jede Referenz dann eine Zeile aus. Bei Dutzenden oder sogar Hunderten von Referenzen ist der einmalige Aufruf ressourcenschonend und daher schneller.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.for-each-ref"></a>8.3.6. Referenzen iterieren: for-each-ref</h3>
              </div>
            </div>
          </div>
          <p>Eine häufige Aufgabe ist es, Referenzen zu iterieren. Hier stellt Git
das Allzweckkommando <code class="literal">for-each-ref</code> zur Verfügung.  Die
gebräuchliche Syntax ist <code class="literal">git for-each-ref --format=&lt;format&gt;
  &lt;muster&gt;</code>. Mit dem Muster können Sie die zu iterierenden Referenzen
einschränken, z.B. <code class="literal">refs/heads</code> oder <code class="literal">refs/tags</code>. Mit
dem Format-Ausdruck geben Sie an, welche Eigenschaften der Referenz
ausgegeben werden soll. Er besteht aus verschiedenen Feldern
<code class="literal">%(feldname)</code>, die in der Ausgabe zu entsprechenden Werten
expandiert werden.</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">refname</code>
</span>
              </dt>
              <dd>
Name der Referenz, z.B. <code class="literal">heads/master</code>.  Der Zusatz
<code class="literal">:short</code> zeigt die Kurzform, also <code class="literal">master</code>.
</dd>
              <dt>
                <span class="term">
<code class="literal">objecttype</code>
</span>
              </dt>
              <dd>
Art des Objekts (<code class="literal">blob</code>, <code class="literal">tree</code>, <code class="literal">commit</code> oder <code class="literal">tag</code>)
</dd>
              <dt>
                <span class="term">
<code class="literal">objectsize</code>
</span>
              </dt>
              <dd>
Objektgröße in Byte
</dd>
              <dt>
                <span class="term">
<code class="literal">objectname</code>
</span>
              </dt>
              <dd>
Commit-ID bzw. SHA-1-Summe
</dd>
              <dt>
                <span class="term">
<code class="literal">upstream</code>
</span>
              </dt>
              <dd>
Remote-Tracking-Branch des Upstream-Branches
</dd>
            </dl>
          </div>
          <p>Hier ein simples Beispiel, wie Sie alle SHA-1-Summen der
Release-Candidates der Version <code class="literal">1.7.1</code> anzeigen:</p>
          <pre class="screen">$ <span class="strong"><strong>git for-each-ref --format='%(objectname)--%(objecttype)--%(refname:\</strong></span>
  <span class="strong"><strong>short)' refs/tags/v1.7.1-rc*</strong></span>
bdf533f9b47dc58ac452a4cc92c81dc0b2f5304f--tag--v1.7.1-rc0
d34cb027c31d8a80c5dbbf74272ecd07001952e6--tag--v1.7.1-rc1
03c5bd5315930d8d88d0c6b521e998041a13bb26--tag--v1.7.1-rc2</pre>
          <p>Beachten Sie, dass die Trennzeichen „<code class="literal">--</code>“ so
übernommen werden und somit zusätzliche Zeichen zur Formatierung
möglich sind.</p>
          <p>Je nach Objekt-Typ sind auch noch andere Feldnamen verfügbar, zum
Beispiel bei einem Tag das Feld <code class="literal">tagger</code>, das den Tag-Autor,
seine E-Mail und das Datum enthält. Gleichzeitig stehen auch die
Felder <code class="literal">taggername</code>, <code class="literal">taggeremail</code> und
<code class="literal">taggerdate</code> zur Verfügung, die jeweils nur den Namen, die
E-Mail und das Datum enthalten.</p>
          <p>Wenn Sie zum Beispiel für ein Projekt wissen wollen, wer jemals ein
Tag erstellt hat:</p>
          <pre class="screen">$ <span class="strong"><strong>git for-each-ref --format='%(taggername)' refs/tags | sort -u</strong></span>
Junio C Hamano
Linus Torvalds
Pat Thoyts
Shawn O. Pearce</pre>
          <p>Als weitere Schnittstelle werden verschiedene Optionen für
Script-Sprachen angeboten, <code class="literal">--shell</code>, <code class="literal">--python</code>,
<code class="literal">--perl</code> und <code class="literal">--tcl</code>. Dadurch werden die Felder
entsprechend als <span class="emphasis"><em>String-Literals</em></span> in der jeweiligen Sprache
formatiert, so dass sie per <code class="literal">eval</code> ausgewertet und in Variablen
übersetzt werden können:</p>
          <pre class="screen">$ <span class="strong"><strong>git for-each-ref --shell --format='ref=%(refname)' refs/tags/v1.7.1.*</strong></span>
ref='refs/tags/v1.7.1.1'
ref='refs/tags/v1.7.1.2'
ref='refs/tags/v1.7.1.3'
ref='refs/tags/v1.7.1.4'</pre>
          <p>Damit lässt sich folgendes Script schreiben, das eine Zusammenfassung
aller Branches ausgibt, die einen Upstream-Branch haben – einschließlich SHA-1-Summe des aktuellsten Commits, dessen Autor und
Tracking-Status. Die Ausgabe ist inhaltlich der von <code class="literal">git branch
  -vv</code> sehr ähnlich, aber etwas lesbarer.  Das Feld
<code class="literal">authorname</code> enthält analog zu <code class="literal">taggername</code> den Namen
des Commit-Autors. Das Kernstück bildet die Anweisung <code class="literal">eval "$daten"</code>, die die zeilenweise Ausgabe von
<code class="literal">for-each-ref</code> in die später verwendeten Variablen übersetzt.</p>
          <pre class="screen">#!/bin/sh
SUBDIRECTORY_OK=Yes
. $(git --exec-path)/git-sh-setup

git for-each-ref --shell --format=\
"refname=%(refname:short) "\
"author=%(authorname) "\
"sha1=%(objectname) "\
"upstream=%(upstream:short)" \
refs/heads | while read daten
do
    eval "$daten"
    if [ -n "$upstream" ] ; then
        ahead=$(git rev-list $upstream..$refname | wc -l)
        behind=$(git rev-list $refname..$upstream | wc -l)
        echo $refname
        echo --------------------
        echo     "    Upstream:      "$upstream
        echo     "    Letzter Autor: "$author
        echo     "    Commit-ID      "$(git rev-parse --short $sha1)
        echo -n  "    Status:        "
        [ $ahead  -gt 0 ] &amp;&amp; echo -n "ahead:"$ahead" "
        [ $behind -gt 0 ] &amp;&amp; echo -n "behind:"$behind" "
        [ $behind -eq 0 ] &amp;&amp; [ $ahead -eq 0 ] &amp;&amp; echo -n "synchron!"
        echo
    fi
done</pre>
          <p>Die Ausgabe sieht dann wie folgt aus:</p>
          <pre class="screen">$ <span class="strong"><strong>git tstatus</strong></span>
maint</pre>
          <pre class="literallayout">    Upstream:      origin/maint
    Letzter Autor: João Britto
    Commit-ID      4c007ae
    Status:        synchron!
master</pre>
          <pre class="screen">    Upstream:      origin/master
    Letzter Autor: Junio C Hamano
    Commit-ID      4e3aa87
    Status:        synchron!
next</pre>
          <pre class="literallayout">    Upstream:      origin/next
    Letzter Autor: Junio C Hamano
    Commit-ID      711ff78
    Status:        behind:22
pu</pre>
          <pre class="screen">    Upstream:      origin/pu
    Letzter Autor: Junio C Hamano
    Commit-ID      dba0393
    Status:        ahead:43 behind:126</pre>
          <p>Die weiteren Feldnamen sowie Beispiele finden Sie in der Man-Page
<code class="literal">git-for-each-ref(1)</code>.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.git-update-ref"></a>8.3.7. Referenzen umschreiben: git update-ref</h3>
              </div>
            </div>
          </div>
          <p>Wer <code class="literal">for-each-ref</code> einsetzt, will meist auch Referenzen
bearbeiten – daher ist das Kommando <code class="literal">update-ref</code> noch zu
erwähnen. Damit können Sie Referenzen anlegen und sicher umsetzen
oder löschen. Grundsätzlich funktioniert <code class="literal">git update-ref</code> mit
zwei bzw. drei Argumenten:</p>
          <pre class="screen">git update-ref &lt;ref&gt; &lt;new-value&gt; [&lt;oldvalue&gt;]</pre>
          <p>Hier ein Beispiel, das den <code class="literal">master</code> auf <code class="literal">HEAD^</code>
verschiebt, sofern dieser auf <code class="literal">HEAD</code> zeigt:</p>
          <pre class="screen">$ <span class="strong"><strong>git update-ref refs/heads/master HEAD^ HEAD</strong></span></pre>
          <p>Oder aber, um eine neue Referenz <code class="literal">topic</code> bei <code class="literal">ea0ccd3</code>
anzulegen:</p>
          <pre class="screen">$ <span class="strong"><strong>git update-ref refs/heads/topic ea0ccd3</strong></span></pre>
          <p>Zum Löschen von Referenzen gibt es die Option <code class="literal">-d</code>:</p>
          <pre class="screen">git update-ref -d &lt;ref&gt; [&lt;oldvalue&gt;]</pre>
          <p>Um beispielsweise die Referenz <code class="literal">topic</code> wieder zu löschen:</p>
          <pre class="screen">$ <span class="strong"><strong>git update-ref -d topic ea0ccd3</strong></span></pre>
          <p>Natürlich könnten Sie die Referenzen auch mit Kommandos wie
<code class="literal">echo &lt;sha&gt; &gt; .git/refs/heads/&lt;ref&gt;</code>
manipulieren, aber <code class="literal">update-ref</code> bringt diverse Sicherheiten und
hilft so möglichen Schaden zu minimieren.  Der Zusatz
<code class="literal">&lt;oldvalue&gt;</code> ist zwar optional, hilft aber
ggf. Programmierfehler zu vermeiden.  Zudem kümmert sich das Kommando
um Spezialfälle (Symlinks, deren Ziel innerhalb oder außerhalb des
Repositorys liegt, Referenzen, die auf andere Referenzen zeigen usw.).
Ein zusätzlicher Vorteil ist, dass <code class="literal">git update-ref</code> automatisch
Einträge im Reflog macht, was die Fehlerbehebung deutlich vereinfacht.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.git-erweiterte-aliase"></a>8.3.8. Erweiterte Aliase</h3>
              </div>
            </div>
          </div>
          <p>Sofern Sie nur einen Einzeiler haben, lohnt sich meist kein eigenes Script.
Git-Aliase wurden für diesen Anwendungsfall entwickelt. Zum Beispiel
ist es möglich, durch ein vorangestelltes Ausrufezeichen externe
Programme aufzurufen, etwa um mit <code class="literal">git k</code> einfach <code class="literal">gitk --all</code> aufzurufen:</p>
          <pre class="screen">$ <span class="strong"><strong>git config --global alias.k '!gitk --all'</strong></span></pre>
          <p>Ein anderes Beispiel, das alle bereits gemergten Branches löscht
und dafür eine Verkettung von Befehlen verwendet, ist:</p>
          <pre class="screen">prune-local = !git branch --merged | grep -v ^* | xargs git branch -d</pre>
          <p>Bei bestimmten Konstrukten kommt es vor, dass Sie die Argumente, die an
das Alias übergeben werden, umstellen oder innerhalb einer Befehlskette
verwenden wollen.  Hierfür eignet sich folgender Trick, bei dem eine
Shell-Funktion in das Alias eingebaut ist:</p>
          <pre class="screen">$ <span class="strong"><strong>git config --global alias.demo '!f(){ echo $2 $1 ; }; f'</strong></span>
$ <span class="strong"><strong>git demo foo bar</strong></span>
bar foo</pre>
          <p>Damit lassen sich auch komplexere Einzeiler elegant als Alias
definieren.  Die folgende Konstruktion filtert für eine bestimmte Datei
heraus, welche Autoren wie viele Commits getätigt haben, in denen die
Datei verändert wurde.  Wenn Sie Patches an die Mailingliste des
Git-Projekts schicken, wird darum gebeten, dass Sie die Mail per
CC auch an die wichtigsten Autoren der von Ihnen veränderten
Dateien schicken. Mit diesem Alias finden Sie heraus, wer das ist.</p>
          <pre class="screen">who-signed = "!f(){ git log -- $1 | \
    grep Signed-off-by | sort | uniq --count | \
    sort --human-numeric-sort --reverse |\
    sed 's/Signed-off-by: / /' | head ; } ; f "</pre>
          <p>Hier gibt es einiges zu beachten: Ein Alias wird immer vom
Toplevel-Verzeichnis des Repositorys ausgeführt, daher muss das
Argument den Pfad innerhalb des Repositorys enthalten. Außerdem
beruht das Alias darauf, dass alle beteiligten Personen den Commit mit
einer <code class="literal">Signed-off-by</code>-Zeile abgesegnet haben, denn anhand
dieser Zeilen wird die Statistik erstellt. Da das Alias über mehrere
Zeilen verteilt ist, muss es mit Anführungszeichen umgeben werden,
sonst kann Git das Alias nicht korrekt interpretieren. Der finale
Aufruf von <code class="literal">head</code> beschränkt die Ausgabe auf die oberen zehn
Autoren:</p>
          <pre class="screen">$ <span class="strong"><strong>git who-signed Documentation/git-svn.txt</strong></span>
     46      Junio C Hamano &lt;gitster@pobox.com&gt;
     30      Eric Wong &lt;normalperson@yhbt.net&gt;
     27      Junio C Hamano &lt;junkio@cox.net&gt;
      5      Jonathan Nieder &lt;jrnieder@uchicago.edu&gt;
      4      Yann Dirson &lt;ydirson@altern.org&gt;
      4      Shawn O. Pearce &lt;spearce@spearce.org&gt;
      3      Wesley J. Landaker &lt;wjl@icecavern.net&gt;
      3      Valentin Haenel &lt;valentin.haenel@gmx.de&gt;
      3      Ben Jackson &lt;ben@ben.com&gt;
      3      Adam Roben &lt;aroben@apple.com&gt;</pre>
          <p>Weitere interessante Ideen und Anregungen finden sich im Git-Wiki auf
der Seite zu Aliasen.<a href="#ftn.idm45240355643920" class="footnote" id="idm45240355643920"><sup class="footnote">[115]</sup></a></p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="sec.filter-branch"></a>8.4. Versionsgeschichte umschreiben</h2>
            </div>
          </div>
        </div>
        <p>Das bereits vorgestellte Kommando <code class="literal">git rebase</code> und dessen
interaktiver Modus erlaubt es Entwicklern, Commits beliebig zu
editieren. Code, der sich noch in der Entwicklung befindet, kann damit
„aufgeräumt“ werden, bevor er (z.B. per Merge) integriert
und so fest mit der Software verschmolzen wird.</p>
        <p>Was aber, wenn nachträglich <span class="emphasis"><em>alle</em></span> Commits geändert werden
sollen, oder zumindest ein großer Teil? Solche Anforderungen
entstehen beispielsweise, wenn ein bis dahin privates Projekt
veröffentlicht werden soll, aber sensitive Daten (Keys, Zertifikate,
Passwörter) in den Commits stecken.</p>
        <p>Git bietet hier das Kommando <code class="literal">filter-branch</code>, mit dem Sie diese
Aufgabe automatisieren. Prinzipiell funktioniert das wie folgt: Sie
geben eine Reihe von Referenzen an, die Git umschreiben soll.  Darüber
hinaus definieren Sie Kommandos, die für die Modifikation der
Commit-Nachricht, der Tree-Inhalte, der Commits etc.  zuständig sind.
Git geht jeden Commit durch und wendet den entsprechenden Filter auf
den entsprechenden Teil an. Die Filter werden per <code class="literal">eval</code> in der
Shell ausgeführt, können also komplette Kommandos oder Namen von
Scripten sein. Die nachfolgende Liste beschreibt die Filter, die Git
anbietet:</p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt>
              <span class="term">
<code class="literal">--env-filter</code>
</span>
            </dt>
            <dd>
Kann dazu verwendet werden, die Umgebungsvariablen,
unter denen der Commit umgeschrieben wird, anzupassen. Speziell die Variablen
<code class="literal">GIT_{AUTHOR,COMMITTER}_{NAME,EMAIL,DATE}</code> lassen
sich so bei Bedarf mit
neuen Werten exportieren.
</dd>
            <dt>
              <span class="term">
<code class="literal">--tree-filter</code>
</span>
            </dt>
            <dd>
Erzeugt für jeden umzuschreibenden Commit einen
Checkout, wechselt in das Verzeichnis und führt den Filter
aus. Anschließend werden neue Dateien automatisch hinzugefügt und alte
gelöscht sowie alle Änderungen übernommen.
</dd>
            <dt>
              <span class="term">
<code class="literal">--index-filter</code>
</span>
            </dt>
            <dd>
Manipuliert den Index.  Verhält sich ähnlich wie
der Tree-Filter, nur dass Git keinen Checkout erstellt, wodurch der
Index-Filter schneller ist.
</dd>
            <dt>
              <span class="term">
<code class="literal">--msg-filter</code>
</span>
            </dt>
            <dd>
Erhält die Commit-Nachricht auf Standard-In und gibt
die neue Nachricht auf Standard-Out aus.
</dd>
            <dt>
              <span class="term">
<code class="literal">--commit-filter</code>
</span>
            </dt>
            <dd>
Wird statt <code class="literal">git commit-tree</code> aufgerufen und kann
so prinzipiell aus einem Commit mehrere machen.  Für Details siehe die
Man-Page.
</dd>
            <dt>
              <span class="term">
<code class="literal">--tag-name-filter</code>
</span>
            </dt>
            <dd>
Wird für alle Tag-Namen aufgerufen, die auf
einen Commit zeigen, der anderweitig umgeschrieben wurde.  Verwenden
Sie <code class="literal">cat</code> als Filter, dann werden die Tags übernommen.
</dd>
            <dt>
              <span class="term">
<code class="literal">--subdirectory-filter</code>
</span>
            </dt>
            <dd>
Nur die Commits anschauen, die das
angegebene Verzeichnis modifizieren. Die umgeschriebene History wird
nur dieses Verzeichnis enthalten, und zwar als oberstes Verzeichnis im
Repository.
</dd>
          </dl>
        </div>
        <p>Die allgemeine Syntax des Kommandos ist: <code class="literal">git filter-branch
  &lt;filter&gt; -- &lt;referenzen&gt;</code>. Dabei ist <code class="literal">&lt;referenzen&gt;</code> ein
Argument für <code class="literal">rev-parse</code>, kann also ein oder mehrere
Branch-Namen sein, eine Syntax der Form <code class="literal">&lt;ref1&gt;..&lt;ref2&gt;</code> oder
einfach <code class="literal">--all</code> für alle Referenzen. Beachten Sie den
Doppelstrich <code class="literal">--</code>, der die Argumente für
<code class="literal">filter-branch</code> von denen für <code class="literal">rev-parse</code> abtrennt!</p>
        <p>Sobald sich einer der Filter bei einem Commit nicht mit dem
Rückgabewert Null beendet, bricht der gesamte Umschreibevorgang ab.
Achten Sie also darauf, mögliche Fehlermeldungen abzufangen oder durch
Anhängen von <code class="literal">|| true</code> zu ignorieren.</p>
        <p>Die ursprünglichen Referenzen werden unter <code class="literal">original/</code>
gespeichert; wenn Sie also den Branch <code class="literal">master</code> umschreiben,
zeigt <code class="literal">original/refs/heads/master</code> noch auf den ursprünglichen,
nicht umgeschriebenen Commit (und entsprechend dessen Vorgänger).
Existiert diese Backup-Referenz bereits, weigert sich das
<code class="literal">filter-branch</code>-Kommando, die Referenz umzuschreiben, es sei
denn, Sie geben die Option <code class="literal">-f</code> für <span class="emphasis"><em>force</em></span> an.</p>
        <div class="tip" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Tipp</h3>
          <p>Sie sollten Ihre <code class="literal">filter-branch</code>-Experimente immer in einem
  frischen Klon machen. Die Chance, durch unglückliche Vertipper
  Schaden anzurichten, ist nicht unerheblich. Gefällt Ihnen das
  Resultat jedoch, können Sie das neue Repository kurzerhand zum
  Haupt-Repository machen, sowie das alte als Backup auslagern.</p>
        </div>
        <p>In den folgenden Beispielen geht es um einige typische Anwendungsfälle
des <code class="literal">filter-branch</code>-Kommandos.</p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.fb-censor"></a>8.4.1. Sensitive Informationen nachträglich entfernen</h3>
              </div>
            </div>
          </div>
          <p>Idealerweise sind sensitive Daten wie Keys, Zertifikate oder
Passwörter nicht Teil eines Repositorys. Auch große Binärdateien oder
anderer Datenmüll blähen die Größe des Repositorys unnötig auf.</p>
          <p>Open-Source-Software, deren Benutzung erlaubt, deren Weitergabe
allerdings durch Lizenzbedingungen untersagt ist (<span class="emphasis"><em>no
  distribution</em></span>), darf natürlich auch nicht in einem Repository
auftauchen, das Sie der Öffentlichkeit zugänglich machen.</p>
          <p>In all diesen Fällen können Sie die Projektgeschichte umschreiben, so
dass niemand herausfinden kann, dass die entsprechenden Daten je in
der Versionsgeschichte des Projekts aufgetaucht sind.</p>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Wenn Sie mit Git-Tags arbeiten, empfiehlt es sich bei diesen
  Operationen immer, auch noch das Argument
  <code class="literal">--tag-name-filter cat</code> zu übergeben, damit Tags, die auf
  umzuschreibende Commits zeigen, auch auf die neue Version zeigen.</p>
          </div>
          <p>Um aus der gesamten Projektgeschichte nur einige Dateien bzw.
Unterverzeichnisse zu löschen, behelfen Sie sich mit einem einfachen
Index-Filter. Sie müssen lediglich Git anweisen, die
entsprechenden Einträge aus dem Index zu entfernen:</p>
          <pre class="screen">$ <span class="strong"><strong>git filter-branch --index-filter \</strong></span>
  <span class="strong"><strong>'git rm --cached --ignore-unmatch &lt;datei&gt;' \</strong></span>
  <span class="strong"><strong>--prune-empty -- --all</strong></span></pre>
          <p>Die Argumente <code class="literal">--cached</code> und <code class="literal">--ignore-unmatch</code>
teilen <code class="literal">git rm</code> mit, nur den Indexeintrag zu entfernen und
nicht mit einem Fehler abzubrechen, wenn der entsprechende Eintrag
nicht existiert (z.B. weil die Datei erst bei einem bestimmten
Commit hinzugefügt wurde). Wollen Sie Verzeichnisse löschen, müssen
Sie zusätzlich <code class="literal">-r</code> angeben.</p>
          <p>Das Argument <code class="literal">--prune-empty</code> sorgt dafür, dass Commits, die
nach Anwendung des Filters den Tree <span class="emphasis"><em>nicht</em></span> verändern,
ausgelassen werden. Wenn Sie also ein Zertifikat mit einem Commit
hinzugefügt haben und dieser Commit durch Entfernen des Zertifikats
somit zu einem „leeren“ Commit wird, dann lässt Git ihn ganz
aus.</p>
          <p>Analog zum obigen Kommando können Sie mit <code class="literal">git mv</code> auch Dateien
oder Verzeichnisse verschieben. Sind die Operationen etwas komplexer,
sollten Sie sich überlegen, einfach mehrere, einfache Filter zu
entwerfen und sie nacheinander aufzurufen.</p>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Möglicherweise hatte eine Datei, die Sie löschen wollen, früher einen
  anderen Namen. Um das zu überprüfen, verwenden Sie das Kommando
  <code class="literal">git log --name-status --follow -- &lt;datei&gt;</code>, um
  eventuelle Umbenennungen aufzuspüren.</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.fb-censor-string"></a>Strings aus Dateien entfernen</h4>
                </div>
              </div>
            </div>
            <p>Falls Sie nicht ganze Dateien, sondern nur bestimmte Zeilen in allen
Commits ändern wollen, reicht ein Filter auf Index-Ebene nicht aus.
Sie müssen einen Tree-Filter verwenden.</p>
            <p>Git wird für jeden Commit den jeweiligen Tree auschecken, in das
entsprechende Verzeichnis wechseln, und dann den Filter ausführen.
Alle Änderungen, die Sie vornehmen, werden übernommen (ohne dass Sie
<code class="literal">git add</code> etc. verwenden müssen).</p>
            <p>Um das Passwort <code class="literal">v3rYs3cr1T</code> aus allen Dateien und allen
Commits zu tilgen, bedarf es folgenden Kommandos:</p>
            <pre class="screen">$ <span class="strong"><strong>git filter-branch --tree-filter 'git ls-files -z | \</strong></span>
  <span class="strong"><strong>xargs -0 -n 1 sed -i "s/v3rYs3cr1T/PASSWORT/g" \</strong></span>
  <span class="strong"><strong>2&gt;/dev/null || true' -- master</strong></span>
Rewrite cbddbd3505086b79dc3b6bd92ac9f811c8a6f4d1 (142/142)
Ref 'refs/heads/master' was rewritten</pre>
            <p>Das Kommando führt eine <span class="emphasis"><em>in-place</em></span>-Ersetzung mit <code class="literal">sed</code>
durch, und zwar auf jeder Datei des Repositorys. Eventuelle
Fehlermeldungen werden weder ausgegeben noch führen sie zu einem
Abbruch des <code class="literal">filter-branch</code>-Aufrufs.</p>
            <p>Nachdem die Referenzen umgeschrieben wurden, können Sie via
Pickaxe-Tool (<code class="literal">-G&lt;ausdruck&gt;</code>, siehe
<a class="xref" href="ch02.html#sec.git-log" title="2.1.6. Die Projektgeschichte untersuchen">Abschnitt 2.1.6, „Die Projektgeschichte untersuchen“</a>) überprüfen, ob wirklich kein Commit mehr den
String <code class="literal">v3rYs3cr1T</code> einführt:</p>
            <pre class="screen">$ <span class="strong"><strong>git log -p -G"v3rYs3cr1T"</strong></span>
# sollte keine Ausgabe erzeugen</pre>
            <div class="tip" style="margin-left: 0; margin-right: 10%;">
              <h3 class="title">Tipp</h3>
              <p>Tree-Filter müssen für jeden Commit den entsprechenden Tree
auschecken. Das erzeugt bei vielen Commits und vielen Dateien einen
erheblichen Overhead, so dass ein <code class="literal">filter-branch</code>-Aufruf sehr
lange dauern kann.</p>
              <p>Durch Angabe von <code class="literal">-d &lt;pfad&gt;</code> können Sie das Kommando
anweisen, den Tree nach <code class="literal">&lt;pfad&gt;</code> statt nach
<code class="literal">.git-rewrite/</code> auszuchecken. Wenn Sie hier ein
<code class="literal">tmpfs</code> verwenden (also insbesondere <code class="literal">/dev/shm</code> oder
<code class="literal">/tmp</code>), dann werden die Dateien nur im Arbeitsspeicher
gehalten, was den Aufruf des Kommandos um einige Größenordnungen
beschleunigen kann.</p>
            </div>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.fb-developer"></a>Einen Entwickler umbenennen</h4>
                </div>
              </div>
            </div>
            <p>Wollen Sie einen Entwickler umbenennen, können Sie dies tun, indem Sie
in einem Environment-Filter ggf. die Variable
<code class="literal">GIT_AUTHOR_NAME</code> ändern. Zum Beispiel so:</p>
            <pre class="screen">$ <span class="strong"><strong>git filter-branch -f --env-filter \</strong></span>
  <span class="strong"><strong>'if [ "$GIT_AUTHOR_NAME" = "Julius Plenz" ];</strong></span>
  <span class="strong"><strong>then export GIT_AUTHOR_NAME="Julius Foobar"; fi' -- master</strong></span></pre>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.fb-subdir"></a>8.4.2. Unterverzeichnis extrahieren</h3>
              </div>
            </div>
          </div>
          <p>Der Subdirectory-Filter erlaubt es, die Commits so umzuschreiben, dass
ein Unterverzeichnis des aktuellen Repositorys neues
Toplevel-Verzeichnis wird. Alle anderen Verzeichnisse sowie das
ehemalige Toplevel-Verzeichnis fallen weg. Commits, die nichts in dem
neuen Unterverzeichnis geändert haben, fallen ebenfalls weg.</p>
          <p>Auf diese Weise können Sie etwa die Versionsgeschichte einer
Bibliothek aus einem größeren Projekt ausgliedern. Der Austausch
zwischen dem ausgegliederten Projekt und dem Basisprojekt kann über
Submodules oder Subtree-Merges funktionieren (siehe dazu  <a class="xref" href="ch05.html#sec.subprojects" title="5.11. Unterprojekte verwalten">Abschnitt 5.11, „Unterprojekte verwalten“</a>).</p>
          <p>Um das Verzeichnis <code class="literal">t/</code> (enthält die Test-Suite) aus dem
Git-Quell-Repository abzuspalten, genügt folgendes Kommando:</p>
          <pre class="screen">$ <span class="strong"><strong>git filter-branch --subdirectory-filter t -- master</strong></span>
Rewrite 2071fb015bc673d2514142d7614b56a37b3faaf2 (5252/5252)
Ref 'refs/heads/master' was rewritten</pre>
          <p>Achtung: Dieses Kommando läuft einige Minuten lang.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.fb-grafts"></a>8.4.3. Grafts: Nachträgliche Merges</h3>
              </div>
            </div>
          </div>
          <p>Git stellt über sogenannte <span class="emphasis"><em>Graft Points</em></span> bzw. <span class="emphasis"><em>Grafts</em></span> (to
graft: einpflanzen) eine Möglichkeit, Merges zu simulieren.  Solche
Grafts werden zeilenweise in der Datei <code class="literal">.git/info/grafts</code>
abgelegt und haben das folgende Format:</p>
          <pre class="screen">commit [parent1 [parent2 ...]]</pre>
          <p>Neben den Informationen, die Git aus den Metadaten der Commits
bezieht, können Sie also für beliebige Commits ein oder mehrere
beliebige Vorgängercommits (Parents) angeben.<a href="#ftn.idm45240355539792" class="footnote" id="idm45240355539792"><sup class="footnote">[116]</sup></a></p>
          <p>Achten Sie darauf, das Repository weiterhin als DAG zu betrachten und
keine Kreise zu schließen: Definieren Sie nicht <code class="literal">HEAD</code> als den
Vorgänger des Root-Commits!  Die Grafts-Datei ist <span class="emphasis"><em>nicht</em></span> Teil
des Repositorys; ein <code class="literal">git clone</code> kopiert diese Informationen
also nicht mit, sie helfen Git lediglich, eine Merge-Basis zu finden.
Bei einem Aufruf von <code class="literal">filter-branch</code> werden diese
Graft-Informationen allerdings fest in die Commits kodiert.</p>
          <p>Das ist vor allem in zwei Fällen sinnvoll: Wenn Sie eine alte
Versionsgeschichte aus einem Tool importieren, das nicht korrekt mit
Merges umgehen kann (z.B. frühere Subversion-Versionen), oder wenn
Sie zwei Versionsgeschichten aneinander „ankleben“ wollen.</p>
          <p>Angenommen, die Entwicklung wurde auf Git umgestellt. Um die
Konvertierung der alten Versionsgeschichte hat sich allerdings noch
niemand gekümmert. Das neue Repository wurde also mit einem initialen
Commit gestartet, der den damaligen Stand des Projekts widerspiegelte.</p>
          <p>Mittlerweile haben Sie die alte Versionsgeschichte erfolgreich nach
Git konvertiert und wollen sie nun <span class="emphasis"><em>vor</em></span> den initialen Commit
(oder stattdessen) anfügen. Dafür gehen Sie so vor:</p>
          <pre class="screen">$ <span class="strong"><strong>cd &lt;neues-repository&gt;</strong></span>
$ <span class="strong"><strong>git fetch &lt;altes-repository&gt; master:old-master</strong></span>
... Konvertierte Commits importieren ...</pre>
          <p>Sie haben nun ein Multi-Root-Repository. Anschließend müssen Sie den
initialen Commit des neuen Repositorys finden (<code class="literal">$old_root</code>)
und den neuesten Commit des alten, konvertierten Repositorys
(<code class="literal">$old_tip</code>) als dessen <span class="emphasis"><em>Vorgänger</em></span> definieren:</p>
          <pre class="screen">$ <span class="strong"><strong>old_root=`git rev-list --reverse master | head -n 1`</strong></span>
$ <span class="strong"><strong>old_tip=`git rev-parse old-master`</strong></span>
$ <span class="strong"><strong>echo $old_root $old_tip &gt; .git/info/grafts</strong></span></pre>
          <p>Schauen Sie sich das Resultat mit Gitk oder einem ähnlichen Programm
an. Wenn Sie zufrieden sind, können Sie die Grafts <span class="emphasis"><em>permanent</em></span>
machen (dabei werden alle Commits ab <code class="literal">$old_tip</code>
umgeschrieben). Dafür wird <code class="literal">git filter-branch</code> ohne Angabe von
Filtern aufgerufen:</p>
          <pre class="screen">$ <span class="strong"><strong>git filter-branch -- $old_tip..</strong></span>
Rewrite 1591ed7dbb3a683b9bf1d880d7a6ef5d252fc0a0 (1532/1532)
Ref 'refs/heads/master' was rewritten
$ <span class="strong"><strong>rm .git/info/grafts</strong></span></pre>
          <p>Außerdem müssen Sie natürlich noch die verbleibenden Backup-Referenzen
löschen (s.u.).</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.fb-clean"></a>8.4.4. Alte Commits löschen</h3>
              </div>
            </div>
          </div>
          <p>Nachdem Sie eventuelle sensitive Daten aus allen Commits getilgt
haben, müssen Sie noch dafür sorgen, dass diese alten Commits nicht
wieder auftauchen. In dem Repository, das Sie umgeschrieben haben,
erfolgt das in drei Schritten:</p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
                <p class="simpara">
Die Backup-Referenzen unter <code class="literal">original/</code> löschen. Das erreichen Sie
  mit folgendem Kommando:
</p>
                <pre class="screen">$ <span class="strong"><strong>git for-each-ref --format='%(refname)' -- 'refs/original/' | \</strong></span>
  <span class="strong"><strong>xargs -n 1 git update-ref -d</strong></span></pre>
                <p class="simpara">Sofern Sie alte Tags oder andere Branches noch nicht umgeschrieben
oder gelöscht haben, müssen Sie dies natürlich vorher erledigen.</p>
              </li>
              <li class="listitem">
                <p class="simpara">
Das Reflog löschen:
</p>
                <pre class="screen">$ <span class="strong"><strong>git reflog expire --verbose --expire=now --all</strong></span></pre>
              </li>
              <li class="listitem">
                <p class="simpara">
Die nun nicht mehr erreichbaren (<span class="emphasis"><em>orphaned</em></span>) Commits löschen. Das
lässt sich am besten über die <code class="literal">gc</code>-Option <code class="literal">--prune</code> regeln, mit der
Sie einstellen, seit wann ein Commit nicht mehr erreichbar sein darf,
damit er gelöscht wird: Ab sofort.
</p>
                <pre class="screen">$ <span class="strong"><strong>git gc --prune=now</strong></span></pre>
              </li>
            </ol>
          </div>
          <p>Sofern andere Entwickler mit einer veralteten Version des Repositorys
arbeiten, müssen sie nun „migrieren“.  Wesentlich ist, dass
sie nicht durch ihre Entwicklungsbranches wieder alte Commits in das
gesäuberte Repository hineinziehen.</p>
          <p>Dafür sollten am besten das neue Repository frisch geklont, wichtige
Branches aus dem alten Repository per <code class="literal">git fetch</code> übernommen
und direkt per Rebase auf die neuen Commits aufgebaut werden. Die
alten Commits können Sie dann dann per <code class="literal">git gc --prune=now</code>
entsorgen.</p>
        </div>
      </div>
      <div class="footnotes">
        <br />
        <hr style="width:100; text-align:left;margin-left: 0" />
        <div id="ftn.idm45240356161168" class="footnote">
          <p><a href="#idm45240356161168" class="simpara"><sup class="simpara">[106] </sup></a>Sie können das Programm
  <code class="literal">indent</code> aus dem GNU-Projekt von
  <a class="ulink" href="http://www.gnu.org/software/indent/" target="_top">http://www.gnu.org/software/indent/</a> herunterladen.</p>
        </div>
        <div id="ftn.idm45240356091632" class="footnote">
          <p><a href="#idm45240356091632" class="simpara"><sup class="simpara">[107] </sup></a>Das Kommando <code class="literal">convert</code> ist
  Teil der ImageMagick-Suite.  Wenn Sie <code class="literal">-clone 1-2</code> durch
  <code class="literal">-clone 0,2</code> ersetzen, werden die unterschiedlichen Bereiche
  aus dem <span class="emphasis"><em>alten</em></span> Bild kopiert.</p>
        </div>
        <div id="ftn.idm45240356082944" class="footnote">
          <p><a href="#idm45240356082944" class="simpara"><sup class="simpara">[108] </sup></a>Die Grafiken wurden zum Release von Kernel
  2.0 von  Larry Ewing erstellt und finden sich unter
  <a class="ulink" href="http://www.isc.tamu.edu/~lewing/linux/" target="_top">http://www.isc.tamu.edu/~lewing/linux/</a>.</p>
        </div>
        <div id="ftn.idm45240356057536" class="footnote">
          <p><a href="#idm45240356057536" class="simpara"><sup class="simpara">[109] </sup></a>„Serverseitig“ heißt hier nur,
  dass sie nicht im lokalen Repository ausgeführt werden, sondern auf
  der „Gegenseite“.</p>
        </div>
        <div id="ftn.idm45240355906016" class="footnote">
          <p><a href="#idm45240355906016" class="simpara"><sup class="simpara">[110] </sup></a>Würde Git die kompletten
  Zugriffsrechte aufnehmen, dann wäre eine Datei gleichen Inhalts bei
  zwei verschiedenen Entwicklern, die unterschiedliche
  <code class="literal">umask(2)</code>-Einstellungen verwenden, nicht der gleiche Blob.
  Um das zu verhindern, verwendet Git ein vereinfachtes
  Rechtemanagement.</p>
        </div>
        <div id="ftn.idm45240355879264" class="footnote">
          <p><a href="#idm45240355879264" class="simpara"><sup class="simpara">[111] </sup></a>Sie können Ihre Shell-Scripte z.B. auf
<a class="ulink" href="http://www.shellcheck.net/" target="_top">http://www.shellcheck.net/</a> automatisch überprüfen lassen.</p>
        </div>
        <div id="ftn.idm45240355876160" class="footnote">
          <p><a href="#idm45240355876160" class="simpara"><sup class="simpara">[112] </sup></a>Die <span class="emphasis"><em>Debian Alquimist
Shell</em></span>, ein Fork der <span class="emphasis"><em>Alquimist Shell</em></span>, ist eine besonders kleine,
schnelle Shell, die POSIX-kompatibel ist. Sie stellt auf vielen
modernen Debian-Systemen sowie auf Ubuntu die Standard-Shell
<code class="literal">/bin/sh</code>.</p>
        </div>
        <div id="ftn.idm45240355872176" class="footnote">
          <p>
            <a href="#idm45240355872176" class="simpara">
              <sup class="simpara">[113] </sup>
            </a>
            <a class="ulink" href="https://github.com/gitbuch/buch-scripte" target="_top">https://github.com/gitbuch/buch-scripte</a>
          </p>
        </div>
        <div id="ftn.idm45240355806064" class="footnote">
          <p><a href="#idm45240355806064" class="simpara"><sup class="simpara">[114] </sup></a>Es gibt noch weitere Flags
  (<code class="literal">U</code>, <code class="literal">T</code> und <code class="literal">B</code>), die aber in der Praxis meist
  keine Rolle spielen.</p>
        </div>
        <div id="ftn.idm45240355643920" class="footnote">
          <p>
            <a href="#idm45240355643920" class="simpara">
              <sup class="simpara">[115] </sup>
            </a>
            <a class="ulink" href="https://git.wiki.kernel.org/index.php/Aliases" target="_top">https://git.wiki.kernel.org/index.php/Aliases</a>
          </p>
        </div>
        <div id="ftn.idm45240355539792" class="footnote">
          <p><a href="#idm45240355539792" class="simpara"><sup class="simpara">[116] </sup></a>Sie können prinzipiell auch <span class="emphasis"><em>gar
    keinen</em></span> Vorgänger angeben. Dann wird der entsprechende Commit zu
  einem Root-Commit.</p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="ch07.html">Zurück</a> </td>
          <td width="20%" align="center"> </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch09.html">Weiter</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top"> </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Zum Anfang</a>
          </td>
          <td width="40%" align="right" valign="top"> </td>
        </tr>
      </table>
    </div>
    <div xmlns="" class="cc-license">
      <hr />
      <p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />Lizensiert unter der <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </p>
    </div>
  </body>
</html>
