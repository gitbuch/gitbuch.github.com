<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Kapitel 3. Praktische Versionsverwaltung</title>
    <link rel="stylesheet" type="text/css" href="gitbuch.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.78.1" />
    <link rel="home" href="index.html" title="Git" />
    <link rel="up" href="index.html" title="Git" />
    <link rel="prev" href="ch02.html" title="Kapitel 2. Grundlagen" />
    <link rel="next" href="ch04.html" title="Kapitel 4. Fortgeschrittene Konzepte" />
    <meta xmlns="" name="language" content="de" />
    <script xmlns="" src="http://hyphenator.googlecode.com/svn/trunk/Hyphenator.js" type="text/javascript"></script>
    <script xmlns="" type="text/javascript">
        Hyphenator.run();
    </script>
  </head>
  <body class="hyphenate">
    <div xmlns="" class="toc">
<p><a href="index.html">Startseite</a></p>
<dl class="toc">
          <dt>
            <span class="preface">
              <a href="pr01.html">Vorwort</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.leser">1. An wen richtet sich dieses Buch?</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.struktur">2. Wie ist das Buch zu lesen?</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.konventionen">3. Konventionen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.install-git-repo">4. Installation und „das Git-Repository“</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.doku">5. Dokumentation und Hilfe</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.kontakt">6. Downloads und Kontakt</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#sec.dank">7. Danksagungen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#chap.vorwort-2te-auflage">8. Vorwort zur 2. Auflage</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="pr01.html#chap.vorwort-cc-ausgabe">9. Vorwort zur CreativeCommons-Ausgabe</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch01.html">1. Einführung und erste Schritte</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch01.html#sec.begriffe">1.1. Grundbegriffe</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch01.html#sec.erste-schritte">1.2. Erste Schritte mit Git</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch01.html#chap.git-config">1.3. Git konfigurieren</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch02.html">2. Grundlagen</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch02.html#sec.grundlagen">2.1. Git-Kommandos</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch02.html#sec.objektmodell">2.2. Das Objektmodell</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch03.html">3. Praktische Versionsverwaltung</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.branches">3.1. Referenzen: Branches und Tags</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.undo">3.2. Versionen wiederherstellen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.merge">3.3. Branches zusammenführen: Merges</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.merge-conflicts">3.4. Merge-Konflikte lösen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.cherry-pick">3.5. Einzelne Commits übernehmen: Cherry-Pick</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.visualization">3.6. Visualisierung von Repositories</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch03.html#sec.reflog">3.7. Reflog</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch04.html">4. Fortgeschrittene Konzepte</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.rebase">4.1. Commits verschieben – Rebase</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.rebase-i">4.2. Die Geschichte umschreiben – Interaktives Rebase</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.blame">4.3. Wer hat diese Änderungen gemacht? – git blame</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.ignore">4.4. Dateien ignorieren</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.stash">4.5. Veränderungen auslagern – git stash</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.notes">4.6. Commits annotieren – git notes</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.multi-root">4.7. Mehrere Root-Commits</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch04.html#sec.bisect">4.8. Regressionen finden – git bisect</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch05.html">5. Verteiltes Git</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.verteilte_systeme">5.1. Wie funktioniert verteilte Versionsverwaltung?</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.clone">5.2. Repositories klonen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.git_fetch">5.3. Commits herunterladen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.hochladen">5.4. Commits hochladen: git push</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.remotes-check">5.5. Remotes untersuchen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.multi-remote">5.6. Verteilter Workflow mit mehreren Remotes</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.remotes-verwalten">5.7. Remotes verwalten</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.remote-tags">5.8. Tags austauschen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.patch-queue">5.9. Patches per E-Mail</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.dictator">5.10. Ein verteilter, hierarchischer Workflow</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch05.html#sec.subprojects">5.11. Unterprojekte verwalten</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch06.html">6. Workflows</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch06.html#sec.workflows-user">6.1. Anwender</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch06.html#sec.branch-modell">6.2. Ein Branching-Modell</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch06.html#sec.releases-management">6.3. Releases-Management</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch07.html">7. Git auf dem Server</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch07.html#sec.server">7.1. Einen Git-Server hosten</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch07.html#sec.gitolite">7.2. Gitolite: Git einfach hosten</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch07.html#sec.git-daemon">7.3. Git-Daemon: Anonymer, lesender Zugriff</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch07.html#sec.gitweb">7.4. Gitweb: Das integrierte Web-Frontend</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch07.html#sec.cgit">7.5. CGit – CGI for Git</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch08.html">8. Git automatisieren</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch08.html#sec.attributes">8.1. Git-Attribute – Dateien gesondert behandeln</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch08.html#sec.hooks">8.2. Hooks</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch08.html#sec.scripting">8.3. Eigene Git-Kommandos schreiben</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch08.html#sec.filter-branch">8.4. Versionsgeschichte umschreiben</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch09.html">9. Zusammenspiel mit anderen Versionsverwaltungssystemen</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch09.html#sec.subversion">9.1. Subversion</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch09.html#sec.fast-import">9.2. Eigene Importer</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch10.html">10. Shell-Integration</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="ch10.html#sec.bash-integration">10.1. Git und die Bash</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="ch10.html#sec.zsh-integration">10.2. Git und die Z-Shell</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="chapter">
              <a href="ch11.html">11. Github</a>
            </span>
          </dt>
          <dt>
            <span class="appendix">
              <a href="apa.html">A. Installation</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="apa.html#linux">A.1. Linux</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="apa.html#sec.osx">A.2. Mac OS X</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="apa.html#sec.windows">A.3. Windows</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="appendix">
              <a href="apb.html">B. Struktur eines Repositorys</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="section">
                  <a href="apb.html#sec.gc">B.1. Aufräumen</a>
                </span>
              </dt>
              <dt>
                <span class="section">
                  <a href="apb.html#sec.gc-performance">B.2. Performance</a>
                </span>
              </dt>
            </dl>
          </dd>
        </dl></div>
    <div class="navheader">
      <table width="100%" summary="Navigation header">
        <tr>
          <td width="20%" align="left"><a accesskey="p" href="ch02.html">Zurück</a> </td>
          <th width="60%" align="center"> </th>
          <td width="20%" align="right"> <a accesskey="n" href="ch04.html">Weiter</a></td>
        </tr>
      </table>
      <hr />
    </div>
    <div class="chapter">
      <div class="titlepage">
        <div>
          <div>
            <h1 class="title"><a id="chap.praxis"></a>Kapitel 3. Praktische Versionsverwaltung</h1>
          </div>
        </div>
      </div>
      <p>Das folgende Kapitel stellt alle wesentlichen Techniken vor, die Sie
im täglichen Umgang mit Git einsetzen werden. Neben einer
genaueren Beschreibung des Index und wie man alte Versionen
wiederherstellt, liegt der Fokus auf der effektiven Arbeit mit
Branches.</p>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="sec.branches"></a>3.1. Referenzen: Branches und Tags</h2>
            </div>
          </div>
        </div>
        <p>„Branch“ und „Merge“ sind im CVS-/SVN-Umfeld für
Neulinge oft ein Buch mit sieben Siegeln, für Könner regelmäßig Grund
zum Haare raufen.  In Git sind das Abzweigen im Entwicklungszyklus
(<span class="emphasis"><em>Branching</em></span>) und das anschließende Wiederzusammenführen
(<span class="emphasis"><em>Merging</em></span>) alltäglich, einfach, transparent und schnell. Es
kommt häufig vor, dass ein Entwickler an einem Tag mehrere Branches
erstellt und mehrere Merges durchführt.</p>
        <p>Das Tool Gitk ist hilfreich, um bei mehreren Branches nicht den
Überblick zu verlieren. Mit
<code class="literal">gitk --all</code> zeigen Sie alle Branches an. Das Tool visualisiert den im vorigen Abschnitt
erläuterten Commit-Graphen. Jeder Commit stellt eine Zeile dar.
Branches werden als grüne Labels, Tags als gelbe Zeiger dargestellt.
Für weitere Informationen siehe <a class="xref" href="ch03.html#sec.gitk" title="3.6.2. Gitk">Abschnitt 3.6.2, „Gitk“</a>.</p>
        <div class="figure">
          <a id="fig.gitk-basic"></a>
          <p class="title">
            <strong>Abbildung 3.1. Das Beispiel-Repository aus <a class="xref" href="ch02.html" title="Kapitel 2. Grundlagen">Kapitel 2, <em>Grundlagen</em></a> in Gitk. Zur Illustration wurde der zweite Commit mit  dem Tag <code class="literal">v0.1</code> versehen.</strong>
          </p>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="bilder_ebook/gitk-basic.png" width="486" alt="bilder_ebook/gitk-basic.png" />
            </div>
          </div>
        </div>
        <br class="figure-break" />
        <p>Da Branches in Git „billig“ und Merges einfach sind, können
Sie es sich leisten, Branches exzessiv zu verwenden.  Sie wollen etwas
probieren, einen kleinen Bugfix vorbereiten oder mit einem
experimentellen Feature beginnen? Für all das erstellen Sie jeweils
einen neuen Branch.  Sie wollen testen, ob sich ein Branch mit dem
anderen verträgt? Führen Sie die beiden zusammen, testen Sie alles,
und löschen Sie danach den Merge wieder und entwickeln weiter.  Das
ist gängige Praxis unter Entwicklern, die Git einsetzen.</p>
        <p>Zunächst wollen wir uns mit Referenzen generell auseinandersetzen.
Referenzen sind nichts weiter als symbolische Namen für die schwierig
zu merkenden SHA-1-Summen von Commits.</p>
        <p>Diese Referenzen liegen in <code class="literal">.git/refs/</code>. Der Name einer
Referenz wird anhand des Dateinamens, das Ziel anhand des Inhalts der
Datei bestimmt. Der Master-Branch, auf dem Sie schon die ganze Zeit
arbeiten, sieht darin zum Beispiel so aus:</p>
        <pre class="screen">$ <span class="strong"><strong>cat .git/refs/heads/master</strong></span>
89062b72afccda5b9e8ed77bf82c38577e603251</pre>
        <div class="tip" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Tipp</h3>
          <p>Wenn Git sehr viele Referenzen verwalten muss, liegen diese nicht
zwingend als Dateien unterhalb von <code class="literal">.git/refs/</code>. Git erstellt
dann stattdessen einen Container, der <span class="emphasis"><em>gepackte Referenzen</em></span> (<span class="emphasis"><em>Packed
Refs</em></span>) enthält: Eine Zeile pro Referenz mit Name und SHA-1-Summe. Das
sequentielle Auflösen vieler Referenzen geht dann schneller.
Git-Kommandos suchen Branches und Tags in der Datei <code class="literal">.git/packed-refs</code>, wenn die entsprechende Datei
<code class="literal">.git/refs/&lt;name&gt;</code> nicht existiert.</p>
        </div>
        <p>Unterhalb von <code class="literal">.git/refs/</code> gibt es verschiedene Verzeichnisse,
die für die „Art“ von Referenz stehen. Fundamental
unterscheiden sich diese Referenzen aber nicht, lediglich darin, wann
und wie sie angewendet werden. Die Referenzen, die Sie am häufigsten
verwenden werden, sind Branches. Sie sind unter <code class="literal">.git/refs/heads/</code> gespeichert. <span class="emphasis"><em>Heads</em></span> bezeichnet das,
was in anderen Systemen zuweilen auch „Tip“ genannt wird:
Den neuesten Commit auf einem Entwicklungsstrang.<a href="#ftn.idm45240359203264" class="footnote" id="idm45240359203264"><sup class="footnote">[29]</sup></a>  Branches rücken weiter, wenn Sie
Commits auf einem Branch erstellen – sie bleiben also an der Spitze
der Versionsgeschichte.</p>
        <div class="figure">
          <a id="fig.commit"></a>
          <p class="title">
            <strong>Abbildung 3.2. Der Branch referenziert immer den aktuellsten Commit</strong>
          </p>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="bilder_ebook/commit.png" width="432" alt="bilder_ebook/commit.png" />
            </div>
          </div>
        </div>
        <br class="figure-break" />
        <p>Branches in Repositories anderer Entwickler (z.B. der Master-Branch
des offiziellen Repositorys), sog.
Remote-Tracking-Branches, werden unter <code class="literal">.git/refs/remotes/</code> abgelegt (siehe <a class="xref" href="ch05.html#sec.remote_tracking_branches" title="5.2.2. Remote-Tracking-Branches">Abschnitt 5.2.2, „Remote-Tracking-Branches“</a>). Tags, statische
Referenzen, die meist der Versionierung dienen, liegen unter <code class="literal">.git/refs/tags/</code> (siehe <a class="xref" href="ch03.html#sec.tags" title="3.1.3. Tags – Wichtige Versionen markieren">Abschnitt 3.1.3, „Tags – Wichtige Versionen markieren“</a>).</p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.branch-refs"></a>3.1.1. HEAD und andere symbolische Referenzen</h3>
              </div>
            </div>
          </div>
          <p>Eine Referenz, die Sie selten explizit, aber ständig implizit
benutzen, ist <code class="literal">HEAD</code>. Sie referenziert meist den gerade
ausgecheckten Branch, hier <code class="literal">master</code>:</p>
          <pre class="screen">$ <span class="strong"><strong>cat .git/HEAD</strong></span>
ref: refs/heads/master</pre>
          <p><code class="literal">HEAD</code> kann auch direkt auf einen Commit zeigen, wenn Sie
<code class="literal">git checkout &lt;commit-id&gt;</code> eingeben. Sie sind dann
allerdings im sogenannten <span class="emphasis"><em>Detached-Head</em></span>-Modus, in dem Commits
möglicherweise verlorengehen, siehe auch
<a class="xref" href="ch03.html#sec.detached-head" title="3.2.1. Detached HEAD">Abschnitt 3.2.1, „Detached HEAD“</a>.</p>
          <p>Der <code class="literal">HEAD</code> bestimmt, welche Dateien im Working Tree zu finden
sind, welcher Commit Vorgänger bei der Erstellung eines neuen wird,
welcher Commit per <code class="literal">git show</code> angezeigt wird etc.  Wenn wir
hier von „dem aktuellen Branch“ sprechen, dann ist damit
technisch korrekt der <code class="literal">HEAD</code> gemeint.</p>
          <p>Die simplen Kommandos <code class="literal">log</code>, <code class="literal">show</code> und <code class="literal">diff</code>
nehmen ohne weitere Argumente <code class="literal">HEAD</code> als erstes Argument an.
Die Ausgabe von <code class="literal">git log</code> ist gleich der von <code class="literal">git log HEAD</code> usw. – dies gilt für die meisten Kommandos, die auf einem
Commit operieren, wenn Sie keinen explizit angeben. <code class="literal">HEAD</code> ist
somit vergleichbar mit der Shell-Variable <code class="literal">PWD</code>, die angibt
„wo man ist“.</p>
          <p>Wenn wir von einem Commit sprechen, dann ist es einem Kommando in der
Regel egal, ob man die Commit-ID komplett oder verkürzt angibt oder
den Commit über eine Referenz, wie z.B. ein Tag oder Branch,
ansteuert. Eine solche Referenz muss aber nicht immer eindeutig sein.
Was passiert, wenn es einen Branch <code class="literal">master</code> gibt und ein Tag
gleichen Namens? Git überprüft, ob die folgenden Referenzen
existieren:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
<code class="literal">.git/&lt;name&gt;</code> (meist nur sinnvoll für <code class="literal">HEAD</code> o.ä.)
</li>
              <li class="listitem">
<code class="literal">.git/refs/&lt;name&gt;</code>
</li>
              <li class="listitem">
<code class="literal">.git/refs/tags/&lt;name&gt;</code>
</li>
              <li class="listitem">
<code class="literal">.git/refs/heads/&lt;name&gt;</code>
</li>
              <li class="listitem">
<code class="literal">.git/refs/remotes/&lt;name&gt;</code>
</li>
              <li class="listitem">
<code class="literal">.git/refs/remotes/&lt;name&gt;/HEAD</code>
</li>
            </ul>
          </div>
          <p>Die erste gefundene Referenz nimmt Git als Treffer an. Sie sollten
also Tags immer ein eindeutiges Schema geben, um sie nicht mit
Branches zu verwechseln. So können Sie Branches direkt über den Namen
statt über <code class="literal">heads/&lt;name&gt;</code> ansprechen.</p>
          <p>Besonders wichtig sind dafür die Suffixe <code class="literal">^</code> und <code class="literal">~&lt;n&gt;</code>. Die Syntax
<code class="literal">&lt;ref&gt;^</code> bezeichnet den direkten Vorfahren von <code class="literal">&lt;ref&gt;</code>. Dieser muss
aber nicht immer eindeutig sein: Wenn zwei oder mehr Branches
zusammengeführt wurden, hat der Merge-Commit mehrere direkte
Vorfahren. <code class="literal">&lt;ref&gt;^</code> bzw. <code class="literal">&lt;ref&gt;^1</code> bezeichnen dann den ersten
<span class="emphasis"><em>direkten</em></span> Vorfahren, <code class="literal">&lt;ref&gt;^2</code> den zweiten usw.<a href="#ftn.idm45240359162272" class="footnote" id="idm45240359162272"><sup class="footnote">[30]</sup></a>  Die Syntax <code class="literal">HEAD^^</code> bedeutet also „der zwei
Ebenen vorher liegende direkte Vorfahre des aktuellen
Commits“. Achten Sie darauf, dass <code class="literal">^</code> in Ihrer Shell möglicherweise
eine spezielle Bedeutung hat und Sie es durch Anführungszeichen oder
mit einem Backslash schützen müssen.</p>
          <div class="figure">
            <a id="fig.relative-refs"></a>
            <p class="title">
              <strong>Abbildung 3.3. Relative-Referenzen, <code class="literal">^</code> und <code class="literal">~&lt;n&gt;</code></strong>
            </p>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="bilder_ebook/relative-refs.png" width="351" alt="bilder_ebook/relative-refs.png" />
              </div>
            </div>
          </div>
          <br class="figure-break" />
          <p>Die Syntax <code class="literal">&lt;ref&gt;~&lt;n&gt;</code> kommt einer
<span class="emphasis"><em>n</em></span>-fachen Wiederholung von <code class="literal">^</code> gleich:
<code class="literal">HEAD~10</code> bezeichnet also den zehnten direkten
Vorgänger des aktuellen Commits. Achtung: Das heißt nicht, dass
zwischen <code class="literal">HEAD</code> und <code class="literal">HEAD~10</code> nur elf
Commits liegen: Da <code class="literal">^</code> bei einem etwaigen Merge nur dem
ersten Strang folgt, liegen zwischen den beiden Referenzen die elf
und alle durch einen Merge integrierten weiteren Commits.
Die Syntax ist übrigens in der Man-Page <code class="literal">git-rev-parse(1)</code> im Abschnitt
„Specifying Revisions“ dokumentiert.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.branch-management"></a>3.1.2. Branches verwalten</h3>
              </div>
            </div>
          </div>
          <p>Ein Branch ist in Git im Nu erstellt.  Git muss lediglich den aktuell
ausgecheckten Commit identifizieren und die SHA-1-Summe in der Datei
<code class="literal">.git/refs/heads/&lt;branch-name&gt;</code> ablegen.</p>
          <pre class="screen">$ <span class="strong"><strong>time git branch neuer-branch</strong></span>
git branch neuer-branch  0.00s user 0.00s system 100% cpu 0.008 total</pre>
          <p>Das Kommando ist so schnell, weil (im Gegensatz zu anderen Systemen)
keine Dateien kopiert und keine weiteren Metadaten abgelegt werden
müssen. Informationen über die Struktur der Versionsgeschichte sind
immer aus dem Commit, den ein Branch referenziert, und seinen
Vorfahren ableitbar.</p>
          <p>Hier eine Übersicht der wichtigsten Optionen:</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">git branch [-v]</code>
</span>
              </dt>
              <dd>
                <p class="simpara">
Listet lokale Branches auf.
  Dabei ist der aktuell ausgecheckte Branch mit einem Sternchen
  markiert. Mit <code class="literal">-v</code> werden außerdem die Commit-IDs, auf die
  die Branches zeigen, sowie die erste Zeile der Beschreibung der
  entsprechenden Commits angezeigt.
</p>
                <pre class="screen">$ <span class="strong"><strong>git branch -v</strong></span>
  maint  65f13f2 Start 1.7.5.1 maintenance track
* master 791a765 Update draft release notes to 1.7.6
  next   b503560 Merge branch 'master' into next
  pu     d7a491c Merge branch 'js/info-man-path' into pu</pre>
              </dd>
              <dt>
                <span class="term">
<code class="literal">git branch &lt;branch&gt; [&lt;ref&gt;]</code>
</span>
              </dt>
              <dd>
Erstellt einen neuen
  Branch <code class="literal">&lt;branch&gt;</code>, der auf Commit <code class="literal">&lt;ref&gt;</code> zeigt
  (<code class="literal">&lt;ref&gt;</code> kann die SHA-1-Summe eines Commits sein, ein
  anderer Branch usw.). Wenn Sie keine Referenz
  angeben, ist dies <code class="literal">HEAD</code>, der aktuelle Branch.
</dd>
              <dt>
                <span class="term">
<code class="literal">git branch -m  &lt;neuer-name&gt;</code>
</span>
              </dt>
              <dd>
                <p class="simpara">
<code class="literal">git branch -m  &lt;alter-name&gt; &lt;neuer-name&gt;</code>
</p>
                <p class="simpara">In der ersten Form
  wird der aktuelle Branch in <code class="literal">&lt;neuer-name&gt;</code> umbenannt.
  In der zweiten Form wird <code class="literal">&lt;alter-name&gt;</code> in
  <code class="literal">&lt;neuer-name&gt;</code> umbenannt.  Das Kommando schlägt fehl,
  wenn dadurch ein anderer Branch überschrieben würde.</p>
                <pre class="screen">$ <span class="strong"><strong>git branch -m master</strong></span>
fatal: A branch named 'master' already exists.</pre>
                <p class="simpara">Wenn Sie einen Branch umbenennen, gibt Git keine Meldung aus. Sie können
also hinterher überprüfen, dass die Umbenennung erfolgreich war:</p>
                <pre class="screen">$ <span class="strong"><strong>git branch</strong></span>
* master
  test
$ <span class="strong"><strong>git branch -m test pu/feature</strong></span>
$ <span class="strong"><strong>git branch</strong></span>
* master
  pu/feature</pre>
              </dd>
              <dt>
                <span class="term">
<code class="literal">git branch -M ...</code>
</span>
              </dt>
              <dd>
Wie <code class="literal">-m</code>, nur dass
  ein Branch auch umbenannt wird, wenn dadurch ein anderer
  überschrieben wird. Achtung: Dabei können Commits des
  überschriebenen Branches verlorengehen!
</dd>
              <dt>
                <span class="term">
<code class="literal">git branch -d &lt;branch&gt;</code>
</span>
              </dt>
              <dd>
Löscht
  <code class="literal">&lt;branch&gt;</code>. Sie können mehrere Branches gleichzeitig
  angeben. Git weigert sich, einen Branch zu löschen,
  wenn er noch nicht komplett in seinen Upstream-Branch, oder, falls
  dieser nicht existiert, in <code class="literal">HEAD</code>, also den aktuellen Branch,
  integriert ist. (Mehr über Upstream-Branches finden Sie in
  <a class="xref" href="ch05.html#sec.pull" title="5.3.2. git pull">Abschnitt 5.3.2, „git pull“</a>.)
</dd>
              <dt>
                <span class="term">
<code class="literal">git branch -D ...</code>
</span>
              </dt>
              <dd>
Löscht einen Branch, auch wenn
  er Commits enthält, die noch nicht in den Upstream- oder aktuellen Branch
  integriert wurden. Achtung: Diese Commits können möglicherweise
  verlorengehen, wenn sie nicht anders referenziert werden.
</dd>
            </dl>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.branch-checkout"></a>Branches wechseln: checkout</h4>
                </div>
              </div>
            </div>
            <p>Branches wechseln Sie mit <code class="literal">git checkout &lt;branch&gt;</code>.  Wenn Sie
einen Branch erstellen und direkt darauf wechseln
wollen, verwenden Sie <code class="literal">git checkout -b &lt;branch&gt;</code>. Das Kommando
ist äquivalent zu <code class="literal">git branch &lt;branch&gt; &amp;&amp; git checkout
  &lt;branch&gt;</code>.</p>
            <p>Was passiert bei einem Checkout? Jeder Branch referenziert einen
Commit, der wiederum einen Tree referenziert, also das Abbild einer
Verzeichnisstruktur. Ein <code class="literal">git checkout &lt;branch&gt;</code> löst nun die
Referenz <code class="literal">&lt;branch&gt;</code> auf einen Commit auf und repliziert den
Tree des Commits auf den Index und auf den Working Tree (d.h.  auf
das Dateisystem).</p>
            <p>Da Git weiß, in welcher Version Dateien aktuell in Index und Working
Tree vorliegen, müssen nur die Dateien, die sich auf dem aktuellen und
dem neuen Branch unterscheiden, ausgecheckt werden.</p>
            <p>Git macht es Anwendern schwer, Informationen zu verlieren. Daher
wird ein Checkout eher fehlschlagen als eventuell nicht abgespeicherte
Änderungen in einer Datei überschreiben. Das passiert in den folgenden
beiden Fällen:</p>
            <div class="itemizedlist">
              <ul class="itemizedlist" style="list-style-type: disc; ">
                <li class="listitem">
Der Checkout würde eine Datei im Working Tree
  überschreiben, in der sich Änderungen befinden. Git gibt folgende
  Fehlermeldung aus: <code class="literal">error: Your local changes to the following files
  would be overwritten by checkout: datei</code>.
</li>
                <li class="listitem">
Der Checkout würde eine ungetrackte Datei überschreiben,
  d.h. eine Datei, die nicht von Git verwaltet wird. Git bricht dann mit
  der Fehlermeldung ab: <code class="literal">error: The following untracked working tree
  files would be overwritten by checkout: datei</code>.
</li>
              </ul>
            </div>
            <p>Liegen allerdings Änderungen im Working Tree oder Index vor, die mit
beiden Branches verträglich sind, übernimmt ein Checkout diese
Änderungen. Das sieht dann z.B. so aus:</p>
            <pre class="screen">$ <span class="strong"><strong>git checkout master</strong></span>
A   neue-datei.txt
Switched to branch <span class="emphasis"><em>master</em></span></pre>
            <p>Das bedeutet, dass die Datei <code class="literal">neue-datei.txt</code> hinzugefügt
wurde, die auf keinem der beiden Branches existiert. Da hier also
keine Informationen verlorengehen können, wird die Datei einfach
übernommen. Die Meldung: <code class="literal">A neue-datei.txt</code> erinnert Sie, um
welche Dateien Sie sich noch kümmern sollten.  Dabei steht <code class="literal">A</code>
für hinzugefügt (<span class="emphasis"><em>added</em></span>), <code class="literal">D</code> für gelöscht (<span class="emphasis"><em>deleted</em></span>)
und <code class="literal">M</code> für geändert (<span class="emphasis"><em>modified</em></span>).</p>
            <p>Wenn Sie ganz sicher sind, dass Sie Ihre Änderungen nicht mehr
brauchen, können Sie per <code class="literal">git checkout -f</code> die Fehlermeldungen
ignorieren und den Checkout trotzdem ausführen.</p>
            <p>Wenn Sie sowohl die Änderungen behalten als auch den Branch wechseln
wollen (Beispiel: Arbeit unterbrechen und auf einem anderen Branch
einen Fehler korrigieren), dann hilft <code class="literal">git stash</code> (<a class="xref" href="ch04.html#sec.stash" title="4.5. Veränderungen auslagern – git stash">Abschnitt 4.5, „Veränderungen auslagern – git stash“</a>).</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.branch-naming"></a>Konventionen zur Benennung von Branches</h4>
                </div>
              </div>
            </div>
            <p>Sie können Branches prinzipiell fast beliebig benennen. Ausnahmen sind
aber Leerzeichen, einige Sonderzeichen mit spezieller Bedeutung für Git
(z.B. <code class="literal">*</code>, <code class="literal">^</code>, <code class="literal">:</code>, <code class="literal">~</code>), sowie zwei aufeinanderfolgende Punkte
(<code class="literal">..</code>) oder ein Punkt am Anfang des Namens.<a href="#ftn.idm45240359083648" class="footnote" id="idm45240359083648"><sup class="footnote">[31]</sup></a></p>
            <p>Sinnvollerweise sollten Sie Branch-Namen immer komplett in
Kleinbuchstaben angeben. Da Git Branch-Namen unter
<code class="literal">.git/refs/heads/</code> als Dateien verwaltet, ist die Groß- und
Kleinschreibung wesentlich.</p>
            <p>Sie können Branches in „Namespaces“ gruppieren, indem Sie
als Separator einen <code class="literal">/</code> verwenden. Branches, die mit der
Übersetzung einer Software zu tun haben, können Sie dann z.B. <code class="literal">i18n/german</code>, <code class="literal">i18n/english</code> etc. nennen. Auch können
Sie, wenn sich mehrere Entwickler ein Repository teilen,
„private“ Branches unter <code class="literal">&lt;username&gt;/&lt;topic&gt;</code>
anlegen. Diese Namespaces werden durch eine Verzeichnisstruktur
abgebildet, so dass dann unter <code class="literal">.git/refs/heads/</code> ein
Verzeichnis <code class="literal">&lt;username&gt;/</code> mit der Branch-Datei <code class="literal">&lt;topic&gt;</code>
erstellt wird.</p>
            <p>Der Hauptentwicklungszweig Ihres Projekts sollte immer <code class="literal">master</code>
heißen. Bugfixes werden häufig auf einem Branch <code class="literal">maint</code> (kurz
für „maintenance“) verwaltet. Das nächste Release wird
meist auf <code class="literal">next</code> vorbereitet. Features, die sich noch in einem
experimentellen Zustand befinden, sollten in <code class="literal">pu</code> (für
„proposed updates“) entwickelt werden oder in
<code class="literal">pu/&lt;feature&gt;</code>. Eine detailliertere Beschreibung, wie Sie mit
Branches die Entwicklung strukturieren und Release-Zyklen
organisieren, finden Sie in <a class="xref" href="ch06.html" title="Kapitel 6. Workflows">Kapitel 6, <em>Workflows</em></a> über Workflows.</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.no-ref-commits"></a>Gelöschte Branches und „verlorene“ Commits</h4>
                </div>
              </div>
            </div>
            <p>Commits kennen jeweils einen oder mehrere Vorgänger. Daher kann man
den Commit-Graphen „gerichtet“, d.h. von neueren zu
älteren Commits, durchlaufen, bis man an einem Wurzel-Commit ankommt.</p>
            <p>Andersherum geht das nicht: Wenn ein Commit seinen Nachfolger kennen
würde, müsste diese Version irgendwo gespeichert werden. Dadurch würde
sich die SHA-1-Summe des Commits ändern, worauf der Nachfolger den
entsprechend neuen Commit referenzieren müsste, dadurch eine neue
SHA-1-Summe erhielte, so dass wiederum der Vorgänger geändert werden
müsste usw.  Git kann also die Commits nur von einer benannten
Referenz aus (z.B.  ein Branch oder <code class="literal">HEAD</code>) in Richtung
früherer Commits durchgehen.</p>
            <p>Wenn daher die „Spitze“ eines Branches gelöscht wird, wird
der oberste Commit nicht mehr referenziert (im Git-Jargon:
<span class="emphasis"><em>unreachable</em></span>). Dadurch wird der Vorgänger nicht mehr
referenziert usw. – bis der nächste Commit auftaucht, der irgendwie
referenziert wird (sei es von einem Branch oder dadurch, dass er einen
Nachfolger hat, der wiederum von einem Branch referenziert wird).</p>
            <p>Wenn Sie einen Branch löschen, werden die Commits auf diesem Branch
also nicht gelöscht, sie gehen nur „verloren“. Git findet
sie einfach nicht mehr.</p>
            <p>In der Objektdatenbank sind sie allerdings noch eine Weile lang
vorhanden.<a href="#ftn.idm45240359063760" class="footnote" id="idm45240359063760"><sup class="footnote">[32]</sup></a>  Sie können also
einen Branch ohne weiteres wiederherstellen, indem Sie den vorherigen
(und vermeintlich gelöschten) Commit explizit als Referenz angeben:</p>
            <pre class="screen">$ <span class="strong"><strong>git branch -D test</strong></span>
Deleted branch test (was e32bf29).
$ <span class="strong"><strong>git branch test e32bf29</strong></span></pre>
            <p>Eine weitere Möglichkeit, gelöschte Commits wiederzufinden, ist das
<span class="emphasis"><em>Reflog</em></span> (siehe dafür <a class="xref" href="ch03.html#sec.reflog" title="3.7. Reflog">Abschnitt 3.7, „Reflog“</a>).</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.tags"></a>3.1.3. Tags – Wichtige Versionen markieren</h3>
              </div>
            </div>
          </div>
          <p>SHA-1-Summen sind zwar eine sehr elegante Lösung, um Versionen
dezentral zu beschreiben, aber semantikarm und für Menschen
unhandlich. Im Gegensatz zu linearen Revisionsnummern sagen uns
Commit-IDs allein nichts über die Reihenfolge der Versionen.</p>
          <p>Während der Entwicklung von Softwareprojekten müssen
verschiedene „wichtige“ Versionen so markiert
werden, dass sie leicht in dem Repository zu finden sind. Die
wichtigsten sind meist solche, die veröffentlicht werden, die
sogenannten <span class="emphasis"><em>Releases</em></span>.  Auch <span class="emphasis"><em>Release Candidates</em></span> werden
häufig auf diese Weise markiert, also Versionen, die die Basis für die
nächste Version bilden und im Zuge der Qualitätssicherung auf
kritische Fehler untersucht werden, ohne dass neue Features
hinzugefügt werden. Je nach Projekt und Entwicklungsmodell gibt es
verschiedene Konventionen, um Releases zu bezeichnen, und Abläufe, wie
sie vorbereitet und publiziert werden.</p>
          <p>Im Open-Source-Bereich haben sich zwei Versionierungsschemata
durchgesetzt: die klassische <span class="emphasis"><em>Major/Minor/Micro-Versionierung</em></span>
und neuerdings auch die <span class="emphasis"><em>datumsbasierte Versionierung</em></span>. Bei der
Major/Minor/Micro-Versionierung, welche z.B. beim Linux-Kernel und
auch Git eingesetzt wird, ist eine Version durch drei (oft auch vier)
Zahlen gekennzeichnet: <code class="literal">2.6.39</code> oder <code class="literal">1.7.1</code>. Bei der
datumsbasierten Versionierung hingegen ist die Bezeichnung aus dem
Zeitpunkt des Releases abgeleitet, z.B.: <code class="literal">2011.05</code> oder
<code class="literal">2011-05-19</code>. Das hat den großen Vorteil, dass das Alter einer
Version leicht ersichtlich ist.<a href="#ftn.idm45240359049680" class="footnote" id="idm45240359049680"><sup class="footnote">[33]</sup></a></p>
          <p>Git bietet Ihnen mit <span class="emphasis"><em>Tags</em></span> („Etiketten“) die Möglichkeit,
beliebige Git-Objekte – meist Commits – zu markieren, um markante
Zustände in der Entwicklungsgeschichte hervorzuheben. Tags sind, wie
Branches auch, als Referenzen auf Objekte implementiert. Im Gegensatz
zu Branches jedoch sind Tags statisch, das heißt, sie werden nicht
verschoben, wenn neue Commits hinzukommen, und zeigen stets auf
dasselbe Objekt. Es gibt zwei Arten von Tags: <span class="emphasis"><em>Annotated</em></span> (mit
Anmerkungen versehen) und <span class="emphasis"><em>Lightweight</em></span>
(„leichtgewichtig“, d.h. ohne Anmerkungen).  Annotated
Tags sind mit Metadaten – z.B. Autor, Beschreibung oder
GPG-Signatur – versehen.  Lightweight Tags zeigen hingegen
„einfach nur“ auf ein bestimmtes Git-Objekt. Für beide Arten
von Tags legt Git unter <code class="literal">.git/refs/tags/</code> bzw.
<code class="literal">.git/packed-refs</code> Referenzen an.  Der Unterschied ist,
dass Git für jedes Annotated Tag ein spezielles Git-Objekt – und zwar
ein <span class="emphasis"><em>Tag-Objekt</em></span> – in der Objektdatenbank anlegt, um die
Metadaten sowie die SHA-1-Summe des markierten Objekts zu speichern,
während ein Lightweight Tag direkt auf das markierte Objekt zeigt.
<a class="xref" href="ch03.html#fig.tag-objekt" title="Abbildung 3.4. Das Tag-Objekt">Abbildung 3.4, „Das Tag-Objekt“</a> zeigt den Inhalt eines Tag-Objekts;
vergleichen Sie auch die anderen Git-Objekte, <a class="xref" href="ch02.html#fig.objekte" title="Abbildung 2.4. Git-Objekte">Abbildung 2.4, „Git-Objekte“</a>.</p>
          <div class="figure">
            <a id="fig.tag-objekt"></a>
            <p class="title">
              <strong>Abbildung 3.4. Das Tag-Objekt</strong>
            </p>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="bilder_ebook/tags.png" width="486" alt="bilder_ebook/tags.png" />
              </div>
            </div>
          </div>
          <br class="figure-break" />
          <p>Das gezeigte Tag-Objekt hat sowohl eine Größe (158 Byte) als auch eine
SHA-1-Summe. Es enthält die Bezeichnung (<code class="literal">0.1</code>), den Objekt-Typ
und die SHA-1-Summe des referenzierten Objekts sowie den Namen und
E-Mail des Autors, der im Git-Jargon <span class="emphasis"><em>Tagger</em></span> heißt. Außerdem
enthält das Tag eine Tag-Message, die zum Beispiel die Version beschreibt,
sowie optional eine GPG-Signatur. Im Git-Projekt etwa besteht eine Tag-Message
aus der aktuellen Versionsbezeichnung und der Signatur des
Maintainers.</p>
          <p>Schauen wir im Folgenden zunächst, wie Sie Tags lokal verwalten. Wie
Sie Tags zwischen Repositories austauschen, beschreibt <a class="xref" href="ch05.html#sec.remote-tags" title="5.8. Tags austauschen">Abschnitt 5.8, „Tags austauschen“</a>.</p>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.tags-verwalten"></a>Tags verwalten</h4>
                </div>
              </div>
            </div>
            <p>Tags verwalten Sie mit dem Kommando <code class="literal">git tag</code>. Ohne Argumente
zeigt es alle vorhandenen Tags an. Je nach Projektgröße lohnt es sich,
die Ausgabe mit der Option <code class="literal">-l</code> und einem entsprechenden Muster
einzuschränken. Mit folgendem Befehl zeigen Sie alle Varianten der
Version <code class="literal">1.7.1</code> des Git-Projekts an, also sowohl die
Release-Candidates mit dem Zusatz <code class="literal">-rc*</code> sowie die
(vierstelligen) Maintenance-Releases:</p>
            <pre class="screen">$ <span class="strong"><strong>git tag -l v1.7.1*</strong></span>
v1.7.1
v1.7.1-rc0
v1.7.1-rc1
v1.7.1-rc2
v1.7.1.1
v1.7.1.2
v1.7.1.3
v1.7.1.4</pre>
            <p>Den Inhalt eines Tags liefert Ihnen <code class="literal">git show</code>:</p>
            <pre class="screen">$ <span class="strong"><strong>git show 0.1 | head</strong></span>
tag 0.1
Tagger: Valentin Haenel &lt;valentin.haenel@gmx.de&gt;
Date:   Wed Mar 23 16:52:03 2011 +0100

Erste Veröffentlichung

commit e2c67ebb6d2db2aab831f477306baa44036af635
Author: Valentin Haenel &lt;valentin.haenel@gmx.de&gt;
Date:   Sat Jan 8 20:30:58 2011 +0100</pre>
            <p>Gitk stellt Tags als gelbe, pfeilartige Kästchen dar, die sich
deutlich von den grünen, rechteckigen Branches unterscheiden:</p>
            <div class="figure">
              <a id="fig.tag-gitk"></a>
              <p class="title">
                <strong>Abbildung 3.5. Tags in Gitk</strong>
              </p>
              <div class="figure-contents">
                <div class="mediaobject">
                  <img src="bilder_ebook/tag-screenshot.png" width="486" alt="bilder_ebook/tag-screenshot.png" />
                </div>
              </div>
            </div>
            <br class="figure-break" />
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.lightweight-tags"></a>Lightweight Tags</h4>
                </div>
              </div>
            </div>
            <p>Um den <code class="literal">HEAD</code> mit einem Lightweight Tag zu versehen, übergeben
Sie den gewünschten Namen an das Kommando (in diesem Beispiel, um einen
wichtigen Commit zu markieren):</p>
            <pre class="screen">$ <span class="strong"><strong>git tag api-aenderung</strong></span>
$ <span class="strong"><strong>git tag</strong></span>
api-aenderung</pre>
            <p>Sie können aber auch die SHA-1-Summe eines Objekts oder eine valide
Revisionsbezeichnung (z.B. <code class="literal">master</code> oder <code class="literal">HEAD~23</code>)
angeben, um ein Objekt nachträglich zu markieren.</p>
            <pre class="screen">$ <span class="strong"><strong>git tag pre-regression HEAD~23</strong></span>
$ <span class="strong"><strong>git tag</strong></span>
api-aenderung
pre-regression</pre>
            <p>Tags sind einzigartig – sollten Sie versuchen, ein Tag erneut zu
erzeugen, bricht Git mit einer Fehlermeldung ab:</p>
            <pre class="screen">$ <span class="strong"><strong>git tag pre-regression</strong></span>
fatal: tag 'pre-regression' already exists</pre>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.annotated-tags"></a>Annotated Tags</h4>
                </div>
              </div>
            </div>
            <p>Annotated Tags erzeugen Sie mit der Option <code class="literal">-a</code>. Wie bei
<code class="literal">git commit</code> öffnet sich ein Editor, mit dem Sie die
Tag-Message verfassen. Oder Sie übergeben die Tag-Message mit der
Option <code class="literal">-m</code> – dann ist die Option <code class="literal">-a</code> redundant:</p>
            <pre class="screen">$ <span class="strong"><strong>git tag -m "Zweite Veröffentlichung" 0.2</strong></span></pre>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.signierte-tags"></a>Signierte Tags</h4>
                </div>
              </div>
            </div>
            <p>Um ein signiertes Tag zu überprüfen, verwenden Sie die Option
<code class="literal">-v</code> (<span class="emphasis"><em>verify</em></span>):</p>
            <pre class="screen">$ <span class="strong"><strong>git tag -v v1.7.1</strong></span>
object d599e0484f8ebac8cc50e9557a4c3d246826843d
type commit
tag v1.7.1
tagger Junio C Hamano &lt;gitster@pobox.com&gt; 1272072587 -0700

Git 1.7.1
gpg: Signature made Sat Apr 24 03:29:47 2010 CEST using DSA key ID F3119B9A
gpg: Good signature from "Junio C Hamano &lt;junkio@cox.net&gt;"
...</pre>
            <p>Das setzt natürlich voraus, dass Sie sowohl GnuPG installiert als auch
den Schlüssel des Signierenden bereits importiert haben.</p>
            <p>Um selbst Tags zu signieren, müssen Sie zunächst den dafür bevorzugten
Key einstellen:</p>
            <pre class="screen">$ <span class="strong"><strong>git config --global user.signingkey &lt;GPG-Key-ID&gt;</strong></span></pre>
            <p>Nun können Sie signierte Tags mit der Option <code class="literal">-s</code> (<span class="emphasis"><em>sign</em></span>)
erstellen:</p>
            <pre class="screen">$ <span class="strong"><strong>git tag -s -m "Dritte Veröffentlichung" 3.0</strong></span></pre>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.tags-loeschen"></a>Tags löschen und überschreiben</h4>
                </div>
              </div>
            </div>
            <p>Mit den Optionen <code class="literal">-d</code> und <code class="literal">-f</code> löschen Sie Tags bzw.
überschreiben sie:</p>
            <pre class="screen">$ <span class="strong"><strong>git tag -d 0.2</strong></span>
Deleted tag '0.2' (was 4773c73)</pre>
            <p>Die Optionen sind mit Vorsicht zu genießen, besonders wenn Sie die
Tags nicht nur lokal verwenden, sondern auch veröffentlichen. Unter
bestimmten Umständen kann es dazu kommen, dass Tags unterschiedliche
Commits bezeichnen – Version <code class="literal">1.0</code> im Repository X zeigt auf
einen anderen Commit als Version <code class="literal">1.0</code> im Repository Y. Aber
sehen Sie hierzu auch <a class="xref" href="ch05.html#sec.remote-tags" title="5.8. Tags austauschen">Abschnitt 5.8, „Tags austauschen“</a>.</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.tags-lightweight-vs-heavyweight"></a>Lightweight vs. Annotated Tags</h4>
                </div>
              </div>
            </div>
            <p>Für die öffentliche Versionierung von Software sind allgemein
Annotated Tags sinnvoller. Sie enthalten im Gegensatz zu Lightweight
Tags Metainformationen, aus denen zu ersehen ist, wer wann ein Tag
erstellt hat – der Ansprechpartner ist eindeutig.  Auch erfahren
Benutzer einer Software so, wer eine bestimmte Version abgesegnet hat.
Zum Beispiel ist klar, dass Junio C. Hamano die Git-Version 1.7.1
getaggt hat – sie hat also quasi sein „Gütesiegel“. Die
Aussage bestätigt natürlich auch die kryptographische Signatur.
Lightweight Tags hingegen eignen sich vor allem, um lokal Markierungen
anzubringen, zum Beispiel um bestimmte, für die aktuelle Aufgabe
relevante Commits zu kennzeichnen. Achten Sie aber darauf, solche Tags
nicht in ein öffentliches Repository hochzuladen (siehe
<a class="xref" href="ch05.html#sec.remote-tags" title="5.8. Tags austauschen">Abschnitt 5.8, „Tags austauschen“</a>), da diese sich sonst verbreiten könnten.
Sofern Sie die Tags nur lokal verwenden, können Sie sie auch löschen,
wenn sie ihren Dienst erfüllt haben (s.o.).</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.non-commit-tags"></a>Non-Commit Tags</h4>
                </div>
              </div>
            </div>
            <p>Mit Tags markieren Sie beliebige Git-Objekte, also nicht nur Commits,
sondern auch Tree-, Blob- und sogar Tag-Objekte selbst! Das klassische
Beispiel ist, den öffentlichen GPG-Schlüssel, der von dem Maintainer
eines Projekts zum Signieren von Tags verwendet wird, in einem Blob zu
hinterlegen.</p>
            <p>So zeigt das Tag <code class="literal">junio-gpg-pub</code> im Git-Repository von Git auf den
Schlüssel von Junio C. Hamano:</p>
            <pre class="screen">$ <span class="strong"><strong>git show junio-gpg-pub | head -5</strong></span>
tag junio-gpg-pub
Tagger: Junio C Hamano &lt;junkio@cox.net&gt;
Date:   Tue Dec 13 16:33:29 2005 -0800

GPG key to sign git.git archive.</pre>
            <p>Weil dieses Blob-Objekt von keinem Tree referenziert wird, ist die
Datei quasi getrennt vom eigentlichen Code, aber dennoch im Repository
vorhanden. Außerdem ist ein Tag auf einen „einsamen“ Blob
notwendig, damit dieser nicht als <span class="emphasis"><em>unreachable</em></span> gilt und im Zuge
der Repository-Wartung gelöscht wird.<a href="#ftn.idm45240358982096" class="footnote" id="idm45240358982096"><sup class="footnote">[34]</sup></a></p>
            <p>Um den Schlüssel zu verwenden, gehen Sie wie folgt vor:</p>
            <pre class="screen">$ <span class="strong"><strong>git cat-file blob junio-gpg-pub | gpg --import</strong></span>
gpg: key F3119B9A: public key "Junio C Hamano &lt;junkio@cox.net&gt;" imported
gpg: Total number processed: 1
gpg:               imported: 1</pre>
            <p>Sie können dann, wie oben beschrieben, alle Tags im Git-via-Git-Repository
verifizieren.</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.git-describe"></a>Commits beschreiben</h4>
                </div>
              </div>
            </div>
            <p>Tags sind sehr nützlich, um beliebige Commits „besser“ zu
beschreiben.  Das Kommando <code class="literal">git describe</code> gibt eine
Beschreibung, die aus dem aktuellsten Tag und dessen relativer
Position im Commit-Graphen besteht. Hier ein Beispiel aus dem
Git-Projekt: Wir beschreiben einen Commit mit dem SHA-1-Präfix <code class="literal">28ba96a</code>,
der sich im Commit-Graphen sieben Commits nach der Version <code class="literal">1.7.1</code>
befindet:</p>
            <div class="figure">
              <a id="fig.describe"></a>
              <p class="title">
                <strong>Abbildung 3.6. Der zu beschreibende Commit in Grau hervorgehoben</strong>
              </p>
              <div class="figure-contents">
                <div class="mediaobject">
                  <img src="bilder_ebook/describe-screenshot.png" width="486" alt="bilder_ebook/describe-screenshot.png" />
                </div>
              </div>
            </div>
            <br class="figure-break" />
            <pre class="screen">$ <span class="strong"><strong>git describe --tags</strong></span>
v1.7.1-7-g28ba96a</pre>
            <p>Die Ausgabe von <code class="literal">git describe</code> ist wie folgt formatiert:</p>
            <pre class="screen">&lt;tag&gt;-&lt;position&gt;-g&lt;SHA-1&gt;</pre>
            <p>Das Tag ist <code class="literal">v1.7.1</code>; die Position besagt, dass sich sieben
neue Commits zwischen dem Tag und dem beschriebenen Commit
befinden.<a href="#ftn.idm45240358966896" class="footnote" id="idm45240358966896"><sup class="footnote">[35]</sup></a>
Das Kürzel <code class="literal">g</code> vor der ID besagt, dass die Beschreibung aus
einem Git-Repository abgeleitet ist, was in Umgebungen mit mehreren
Versionsverwaltungssystemen nützlich ist.  Standardmäßig sucht
<code class="literal">git describe</code> nur nach Annotated Tags, mit der Option
<code class="literal">--tags</code> erweitern Sie die Suche auch auf Lightweight Tags.</p>
            <p>Das Kommando ist sehr nützlich, weil es einen inhaltsbasierten
Bezeichner in etwas für Menschen Sinnvolles übersetzt:
<code class="literal">v1.7.1-7-g28ba96a</code> ist deutlich näher an <code class="literal">v1.7.1</code> als
<code class="literal">v1.7.1-213-g3183286</code>. Dadurch können Sie die Ausgaben sinnvoll – wie im Git-Projekt auch – direkt in die Software einkompilieren:</p>
            <pre class="screen">$ <span class="strong"><strong>git describe</strong></span>
v1.7.5-rc2-8-g0e73bb4
$ <span class="strong"><strong>make</strong></span>
GIT_VERSION = 1.7.5.rc2.8.g0e73bb
...
$ <span class="strong"><strong>./git --version</strong></span>
git version 1.7.5.rc2.8.g0e73bb</pre>
            <p>Somit weiß ein Benutzer ungefähr, welche Version er hat, und kann
nachvollziehen, aus welchem Commit die Version kompiliert wurde.</p>
          </div>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="sec.undo"></a>3.2. Versionen wiederherstellen</h2>
            </div>
          </div>
        </div>
        <p>Ziel einer Versionskontrollsoftware ist es nicht nur, Änderungen
zwischen Commits zu untersuchen. Wichtig ist vor allem auch, ältere
Versionen einer Datei oder ganzer Verzeichnisbäume wiederherzustellen
oder Änderungen rückgängig zu machen. Dafür sind in Git insbesondere
die Kommandos <code class="literal">checkout</code>, <code class="literal">reset</code> und <code class="literal">revert</code>
zuständig.</p>
        <p>Das Git-Kommando <code class="literal">checkout</code> kann nicht nur Branches wechseln,
sondern auch Dateien aus früheren Commits wiederherstellen. Die Syntax
lautet allgemein:</p>
        <pre class="screen">git checkout [-f] &lt;referenz&gt; -- &lt;muster&gt;</pre>
        <p><code class="literal">checkout</code> löst die angegebene Referenz (und wenn diese fehlt,
<code class="literal">HEAD</code>) auf einen Commit auf und extrahiert alle Dateien, die
auf <code class="literal">&lt;muster&gt;</code> passen, in den Working Tree. Ist
<code class="literal">&lt;muster&gt;</code> ein Verzeichnis, bezieht sich das auf alle darin
enthaltenen Dateien und Unterverzeichnisse. Sofern Sie kein Muster
explizit angeben, werden alle Dateien ausgecheckt.  Dabei werden
Änderungen an einer Datei nicht einfach überschrieben, es sei denn,
Sie geben die Option <code class="literal">-f</code> an (s.o.). Außerdem wird
<code class="literal">HEAD</code> auf den entsprechenden Commit (bzw. Branch) gesetzt.</p>
        <p>Wenn Sie allerdings ein Muster angeben, dann überschreibt
<code class="literal">checkout</code> diese Datei(en) ohne Nachfrage. Um also alle
Änderungen an <code class="literal">&lt;datei&gt;</code> zu
verwerfen, geben Sie <code class="literal">git checkout -- &lt;datei&gt;</code> ein: Git
ersetzt dann <code class="literal">&lt;datei&gt;</code> durch die Version im aktuellen Branch.
Auf diese Weise können Sie auch den älteren Zustand einer Datei
rekonstruieren:</p>
        <pre class="screen">$ <span class="strong"><strong>git checkout ce66692 -- &lt;datei&gt;</strong></span></pre>
        <p>Das doppelte Minus trennt die Muster von den Optionen bzw.
Argumenten. Es ist allerdings nicht notwendig: Gibt es keine Branches
oder andere Referenzen mit dem Namen, versucht Git, eine solche Datei
zu finden. Die Separierung macht also nur eindeutig, dass Sie die
entsprechende(n) Datei(en) wiederherstellen möchten.</p>
        <p>Um den Inhalt einer Datei aus einem bestimmten Commit anzuschauen,
ohne sie auszuchecken, nutzen Sie das folgende Kommando:</p>
        <pre class="screen">$ <span class="strong"><strong>git show ce66692:&lt;datei&gt;</strong></span></pre>
        <div class="tip" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Tipp</h3>
          <p>Mit <code class="literal">--patch</code> bzw. <code class="literal">-p</code> rufen Sie <code class="literal">git checkout</code> im interaktiven Modus
auf. Der Ablauf ist der gleiche wie bei <code class="literal">git add -p</code> (siehe
<a class="xref" href="ch02.html#sec.add-p" title="2.1.2. Commits schrittweise erstellen">Abschnitt 2.1.2, „Commits schrittweise erstellen“</a>), jedoch können Sie hier Hunks einer Datei schrittweise
zurücksetzen.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.detached-head"></a>3.2.1. Detached HEAD</h3>
              </div>
            </div>
          </div>
          <p>Wenn Sie einen Commit auschecken, der nicht durch einen Branch
referenziert wird, befinden Sie sich im sogenannten
<span class="emphasis"><em>Detached-HEAD</em></span>-Modus:</p>
          <pre class="screen">$ <span class="strong"><strong>git checkout 3329661</strong></span>
Note: checking out '3329661'.

You are in 'detached HEAD' state. You can look around, make
experimental changes and commit them, and you can discard any
commits you make in this state without impacting any branches
by performing another checkout.

If you want to create a new branch to retain commits you create,
you may do so (now or later) by using -b with the checkout command
again. Example:

  git checkout -b new_branch_name

HEAD is now at 3329661... Add LICENSE file</pre>
          <p>Wie die Erklärung, die Sie durch setzen der Option
<code class="literal">advice.detachedHead</code> auf <code class="literal">false</code> ausblenden können,
schon warnt, werden Änderungen, die Sie nun tätigen, im Zweifel
verlorengehen: Da Ihr <code class="literal">HEAD</code> danach die einzige direkte
Referenz auf den Commit ist, werden weitere Commits nicht direkt von
einem Branch referenziert (sie sind <span class="emphasis"><em>unreachable</em></span>, s.o.).</p>
          <p>Im Detached-HEAD-Modus zu arbeiten bietet sich also vor allem dann an,
wenn Sie schnell etwas probieren wollen: Ist der Fehler eigentlich
schon im Commit <code class="literal">3329661</code> aufgetaucht? Gab es zum
Zeitpunkt von <code class="literal">3329661</code> eigentlich schon die Datei
<code class="literal">README</code>?</p>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Wenn Sie von dem ausgecheckten Commit aus mehr
machen wollen als sich bloß umzuschauen und beispielsweise testen möchten,
ob Ihre Software schon damals einen bestimmten Bug hatte, sollten Sie
einen Branch erstellen:</p>
            <pre class="screen">$ <span class="strong"><strong>git checkout -b &lt;temp-branch&gt;</strong></span></pre>
            <p>Dann können Sie wie gewohnt Commits machen, ohne befürchten zu müssen,
dass diese verlorengehen.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.revert"></a>3.2.2. Commits rückgängig machen</h3>
              </div>
            </div>
          </div>
          <p>Wenn Sie alle Änderungen, die ein Commit einbringt, rückgängig machen
wollen, hilft das Kommando <code class="literal">revert</code>. Es löscht aber keinen
Commit, sondern erstellt einen neuen, dessen Änderungen genau dem
Gegenteil des anderen Commits entsprechen: Gelöschte Zeilen werden zu
hinzugefügten und umgekehrt.</p>
          <p>Angenommen, Sie haben einen Commit, der eine Datei <code class="literal">LICENSE</code>
erstellt. Der Patch des entsprechenden Commits sieht so aus:</p>
          <pre class="screen">--- /dev/null
+++ b/LICENSE
@@ -0,0 +1 @@
+This software is released under the GNU GPL version 3 or newer.</pre>
          <p>Nun können Sie die Änderungen rückgängig machen:</p>
          <pre class="screen">$ <span class="strong"><strong>git revert 3329661</strong></span>
Finished one revert.
[master a68ad2d] Revert "Add LICENSE file"
 1 files changed, 0 insertions(+), 1 deletions(-)
 delete mode 100644 LICENSE</pre>
          <p>Git erstellt einen neuen Commit auf dem aktuellen Branch – sofern Sie
nichts anderes angeben – mit der Beschreibung <code class="literal">Revert "&lt;Alte Commit-Nachricht&gt;"</code>. Dieser Commit sieht so aus:</p>
          <pre class="screen">$ <span class="strong"><strong>git show</strong></span>
commit a68ad2d41e9219383449d703521573477ee7da48
Author: Julius Plenz &lt;feh@mali&gt;
Date:   Mon Mar 7 05:28:47 2011 +0100

    Revert "Add LICENSE file"

    This reverts commit 3329661775af3c52e6b2ad7e9e7e7d789ba62712.

diff --git a/LICENSE b/LICENSE
deleted file mode 100644
index 3fd9c20..0000000
--- a/LICENSE
+++ /dev/null
@@ -1 +0,0 @@
-This software is released under the GNU GPL version 3 or newer.</pre>
          <p>Beachten Sie also, dass in der Versionsgeschichte eines Projekts ab
nun sowohl der Commit als auch der Revert auftauchen. Sie machen also
nur die <span class="emphasis"><em>Änderungen</em></span> rückgängig, löschen aber keine Informationen
aus der Versionsgeschichte.</p>
          <p>Sie sollten daher <code class="literal">revert</code> nur einsetzen, wenn Sie eine
Änderung, die bereits veröffentlicht wurde, rückgängig machen müssen.
Entwickeln Sie allerdings lokal in einem eigenen Branch, ist es
sinnvoller, diese Commits komplett zu löschen (siehe dafür den
folgenden Abschnitt über <code class="literal">reset</code> sowie das Thema <span class="emphasis"><em>Rebase</em></span>, <a class="xref" href="ch04.html#sec.rebase" title="4.1. Commits verschieben – Rebase">Abschnitt 4.1, „Commits verschieben – Rebase“</a>).</p>
          <p>Sofern Sie einen Revert durchführen wollen, allerdings nicht für
sämtliche Änderungen des Commits, sondern nur für die einer Datei,
können Sie sich zum Beispiel so behelfen:</p>
          <pre class="screen">$ <span class="strong"><strong>git show -R 3329661 -- LICENSE | git apply --index</strong></span>
$ <span class="strong"><strong>git commit -m 'Revert change to LICENSE from 3329661'</strong></span></pre>
          <p>Das Kommando <code class="literal">git show</code> gibt die Änderungen von Commit
<code class="literal">3329661</code> aus, die sich auf die Datei <code class="literal">LICENSE</code>
beziehen. Die Option <code class="literal">-R</code> sorgt dafür, dass das
Unified-Diff-Format „andersherum“ angezeigt wird
(<span class="emphasis"><em>reverse</em></span>). Die Ausgabe wird an <code class="literal">git apply</code>
weitergeleitet, um die Änderungen an der Datei und dem Index
vorzunehmen. Anschließend werden die Änderungen eingecheckt.</p>
          <p>Eine weitere Möglichkeit, eine Änderung rückgängig zu machen, besteht
darin, eine Datei aus einem vorherigen Commit auszuchecken, sie dem
Index hinzuzufügen und neu einzuchecken:</p>
          <pre class="screen">$ <span class="strong"><strong>git checkout 3329661 -- &lt;datei&gt;</strong></span>
$ <span class="strong"><strong>git add &lt;datei&gt;</strong></span>
$ <span class="strong"><strong>git commit -m 'Reverting &lt;datei&gt; to resemble 3329661'</strong></span></pre>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.reset"></a>3.2.3. Reset und der Index</h3>
              </div>
            </div>
          </div>
          <p>Wenn Sie einen Commit gänzlich löschen, also nicht nur rückgängig
machen, dann verwenden Sie <code class="literal">git reset</code>. Das Reset-Kommando
setzt den <code class="literal">HEAD</code> (und damit auch den aktuellen Branch) sowie
wahlweise auch Index und Working Tree auf einen bestimmten Commit.
Die Syntax lautet <code class="literal">git reset [&lt;option&gt;] [&lt;commit&gt;]</code>.</p>
          <p>Die wichtigsten Reset-Typen sind die folgenden:</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">--soft</code>
</span>
              </dt>
              <dd>
Setzt nur den <code class="literal">HEAD</code> zurück;
  Index und Working Tree bleiben unberührt.
</dd>
              <dt>
                <span class="term">
<code class="literal">--mixed</code>
</span>
              </dt>
              <dd>
Voreinstellung, wenn Sie keine Option
  angeben. Setzt <code class="literal">HEAD</code> und Index auf den angegebenen Commit,
  die Dateien im Working Tree bleiben aber unberührt.
</dd>
              <dt>
                <span class="term">
<code class="literal">--hard</code>
</span>
              </dt>
              <dd>
Synchronisiert <code class="literal">HEAD</code>, Index und
  Working Tree und setzt sie auf den gleichen Commit. Dabei gehen
  möglicherweise Änderungen im Working Tree verloren!
</dd>
            </dl>
          </div>
          <p>Wenn Sie <code class="literal">git reset</code> ohne Optionen aufrufen, entspricht dies
einem <code class="literal">git reset --mixed HEAD</code>. Das Kommando haben wir schon
kennengelernt: Git setzt den aktuellen <code class="literal">HEAD</code> auf
<code class="literal">HEAD</code> (verändert ihn also nicht) und den Index auf
<code class="literal">HEAD</code> – dabei gehen die vorher hinzugefügten Änderungen
verloren.</p>
          <p>Die Anwendungsmöglichkeiten dieses Kommandos sind vielfältig und werden
in den verschiedenen Kommandosequenzen wieder auftauchen. Daher ist
es wichtig, die Funktionalität zu verstehen, auch wenn es teilweise
alternative Kommandos gibt, die den gleichen Effekt haben.</p>
          <p>Angenommen, Sie haben auf <code class="literal">master</code> zwei Commits gemacht, die Sie
eigentlich auf einen neuen Branch verschieben wollen, um noch weiter
daran zu arbeiten.  Die folgende Kommandosequenz erstellt einen neuen
Branch, der auf den <code class="literal">HEAD</code> zeigt, und setzt anschließend
<code class="literal">HEAD</code> und damit den aktuellen Branch <code class="literal">master</code> zwei
Commits zurück. Dann checken Sie den neuen Branch
<code class="literal">&lt;neues-feature&gt;</code> aus.</p>
          <pre class="screen">$ <span class="strong"><strong>git branch &lt;neues-feature&gt;</strong></span>
$ <span class="strong"><strong>git reset --hard HEAD^^</strong></span>
$ <span class="strong"><strong>git checkout &lt;neues-feature&gt;</strong></span></pre>
          <p>Alternativ hat die folgende Sequenz den gleichen Effekt: Sie
erstellen einen Branch <code class="literal">&lt;neues-feature&gt;</code>, der auf den
aktuellen Commit zeigt. Dann löschen Sie <code class="literal">master</code> und erstellen
ihn neu, so dass er auf den zweiten Vorgänger des aktuellen Commits
zeigt.</p>
          <pre class="screen">$ <span class="strong"><strong>git checkout -b &lt;neues-feature&gt;</strong></span>
$ <span class="strong"><strong>git branch -D master</strong></span>
$ <span class="strong"><strong>git branch master HEAD^^</strong></span></pre>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.reset-usage"></a>reset benutzen</h4>
                </div>
              </div>
            </div>
            <p>Mit <code class="literal">reset</code> löschen Sie nicht beliebige Commits, sondern
verschieben immer nur Referenzen. Dadurch gehen die nicht mehr
referenzierten Commits verloren, werden also quasi gelöscht
(<span class="emphasis"><em>unreachable</em></span>). Sie können also mit <code class="literal">reset</code> nur die
obersten Commits auf einem Branch löschen, nicht beliebige Commits
„irgendwo aus der Mitte“, da dies den Commit-Graphen
zerstören würde. (Für das etwas kompliziertere Löschen von Commits
„mittendrin“ siehe Rebase, <a class="xref" href="ch04.html#sec.rebase" title="4.1. Commits verschieben – Rebase">Abschnitt 4.1, „Commits verschieben – Rebase“</a>.)</p>
            <p>Git speichert den ursprünglichen <code class="literal">HEAD</code> immer unter
<code class="literal">ORIG_HEAD</code> ab. Falls Sie also fälschlicherweise einen Reset durchgeführt haben, machen Sie diesen mit <code class="literal">git reset --hard ORIG_HEAD</code>
rückgängig (auch wenn der Commit vermeintlich gelöscht wurde).  Das
betrifft allerdings <span class="emphasis"><em>nicht</em></span> die verlorengegangenen Änderungen am
Working Tree (die Sie noch nicht eingecheckt haben) – diese werden
unwiderruflich gelöscht.</p>
            <p>Das Resultat von oben (zwei Commits auf einen neuen Branch
verschieben) erreichen Sie also alternativ auch so:</p>
            <pre class="screen">$ <span class="strong"><strong>git reset --hard HEAD^^</strong></span>
$ <span class="strong"><strong>git checkout -b &lt;neues-feature&gt; ORIG_HEAD</strong></span></pre>
            <p>Eine häufige Anwendung von <code class="literal">reset</code> ist, testweise Änderungen zu
verwerfen. Sie wollen einen Patch probieren? Ein bisschen
Debugging-Output einbauen? Ein paar Konstanten ändern? Gefällt das
Ergebnis nicht, löscht ein <code class="literal">git reset --hard</code> alle
Änderungen am Working Tree.</p>
            <p>Auch können Sie mit Hilfe von <code class="literal">reset</code> Ihre Versionsgeschichte
„schön machen“. Wenn Sie beispielsweise ein paar Commits auf
einem auf <code class="literal">master</code> aufbauenden Branch <code class="literal">&lt;feature&gt;</code>
haben, die aber nicht  sinnvoll gegliedert (oder viel zu groß)
sind, können Sie einen Branch <code class="literal">&lt;reorder-feature&gt;</code>
erstellen und <span class="emphasis"><em>alle</em></span> Änderungen in neue Commits verpacken:</p>
            <pre class="screen">$ <span class="strong"><strong>git checkout -b &lt;reorder-feature&gt; &lt;feature&gt;</strong></span>
$ <span class="strong"><strong>git reset master</strong></span>
$ <span class="strong"><strong>git add -p</strong></span>
$ <span class="strong"><strong>git commit</strong></span>
$ ...</pre>
            <p>Das Kommando <code class="literal">git reset master</code> setzt Index und <code class="literal">HEAD</code>
auf den Stand von <code class="literal">master</code>. Ihre Änderungen im Working Tree
bleiben aber erhalten, d.h. alle Änderungen, die den Branch
<code class="literal">&lt;feature&gt;</code> von <code class="literal">master</code> unterscheiden, sind nun
lediglich in den Dateien im Working Tree enthalten. Jetzt können Sie
die Änderungen <span class="emphasis"><em>schrittweise</em></span> per <code class="literal">git add -p</code> hinzufügen
und in (mehrere) handliche Commits verpacken.<a href="#ftn.idm45240358843888" class="footnote" id="idm45240358843888"><sup class="footnote">[36]</sup></a></p>
            <p>Angenommen, Sie arbeiten an einer Änderung und wollen diese temporär
einchecken (um später daran weiterzuarbeiten). Dann können Sie
folgende Kommandos verwenden:</p>
            <pre class="screen">$ <span class="strong"><strong>git commit -m 'feature (noch unfertig)'</strong></span>
(später)
$ <span class="strong"><strong>git reset --soft HEAD^</strong></span>
(weiterarbeiten)</pre>
            <p>Das Kommando <code class="literal">git reset --soft HEAD^</code> setzt den
<code class="literal">HEAD</code> einen Commit zurück, lässt allerdings den Index sowie
den Working Tree unberührt. Alle Änderungen aus Ihrem temporären
Commit sind also nach wie vor im Index und Working Tree, aber der
eigentliche Commit geht verloren. Sie können nun weitere Änderungen
machen und später einen neuen Commit erstellen. Eine ähnliche
Funktionalität stellt die Option <code class="literal">--amend</code> für <code class="literal">git
  commit</code> sowie auch das Kommando <code class="literal">git stash</code> (dt.
„verstauen“) bereit, das in <a class="xref" href="ch04.html#sec.stash" title="4.5. Veränderungen auslagern – git stash">Abschnitt 4.5, „Veränderungen auslagern – git stash“</a> erklärt
wird.</p>
          </div>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="sec.merge"></a>3.3. Branches zusammenführen: Merges</h2>
            </div>
          </div>
        </div>
        <p>Das Zusammenführen von Branches nennt man in Git <span class="emphasis"><em>mergen</em></span>;
der Commit, der zwei oder mehr Branches miteinander verbindet,
heißt entsprechend <span class="emphasis"><em>Merge-Commit</em></span>.</p>
        <p>Git stellt das Subkommando <code class="literal">merge</code> bereit, mit dem Sie einen
Branch in einen anderen integrieren. Das bedeutet, dass alle
Änderungen, die Sie auf dem Branch getätigt haben, in den aktuellen
einfließen.</p>
        <p>Beachten Sie, dass das Kommando den angegebenen Branch in den
<span class="emphasis"><em>aktuell ausgecheckten Branch</em></span> (d.h. <code class="literal">HEAD</code>)
integriert. Das Kommando benötigt also nur ein Argument:</p>
        <pre class="screen">$ <span class="strong"><strong>git merge &lt;branch-name&gt;</strong></span></pre>
        <p>Wenn Sie wohlüberlegt mit Ihren Branches hantieren, dürfte es
keine Probleme beim Mergen geben. Wenn doch, dann stellen
wir in diesem Abschnitt auch Strategien vor, wie Sie Merge-Konflikte
lösen.</p>
        <p>Zunächst schauen wir uns einen Merge-Vorgang auf Objektebene an.</p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.merge-detail"></a>3.3.1. Zwei Branches verschmelzen</h3>
              </div>
            </div>
          </div>
          <p>Die zwei Branches <code class="literal">topic</code> und <code class="literal">master</code>, die Sie mergen
wollen, referenzieren jeweils den aktuellsten Commit in einer Kette
von Commits (F und D), und diese beiden Commits wiederum einen Tree
(entspricht dem obersten Verzeichnis Ihres Projekts).</p>
          <p>Zunächst berechnet Git eine sogenannte <span class="emphasis"><em>Merge-Basis</em></span>, also einen
Commit, den beide zu verschmelzenden Commits als gemeinsamen Vorfahren
haben. In der Regel gibt es mehrere solcher Basen – im untenstehenden
Diagramm A und B – , dann wird die neueste (die also die anderen Basen
als Vorfahren hat) verwendet.<a href="#ftn.idm45240358822816" class="footnote" id="idm45240358822816"><sup class="footnote">[37]</sup></a>
Anschaulich gesprochen, ist dies für einfache Fälle der Commit, an dem
die Branches divergiert haben (also B).</p>
          <p>Wenn Sie nun zwei Commits miteinander verschmelzen wollen (D und F zu
M), dann müssen also die von den Commits referenzierten Trees
verschmolzen werden.</p>
          <div class="figure">
            <a id="fig.merge-base-commit"></a>
            <p class="title">
              <strong>Abbildung 3.7. Merge-Basis und Merge-Commit</strong>
            </p>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="bilder_ebook/merge-base-commit.png" width="378" alt="bilder_ebook/merge-base-commit.png" />
              </div>
            </div>
          </div>
          <br class="figure-break" />
          <p>Dafür geht Git so vor:<a href="#ftn.idm45240358816896" class="footnote" id="idm45240358816896"><sup class="footnote">[38]</sup></a>  Wenn ein Tree-Eintrag (ein
weiterer Tree oder ein Blob) in beiden Commits gleich ist, wird
genau dieser Tree-Eintrag auch im Merge-Commit übernommen. Das
passiert in zwei Fällen:</p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
Eine Datei wurde von keinem der beiden Commits geändert, oder ein Unterverzeichnis enthält keine geänderte Datei: Im ersten Fall ist die Blob-SHA-1-Summe dieser Datei in beiden Commits gleich, im zweiten Fall wird von beiden Commits das gleiche Tree-Objekt referenziert. Der referenzierte Blob bzw. Tree ist also derselbe wie der in der Merge-Basis referenzierte.
</li>
              <li class="listitem">
Eine Datei wurde <span class="emphasis"><em>auf beiden Seiten</em></span> und <span class="emphasis"><em>äquivalent</em></span> geändert (gleiche Blobs). Das passiert zum Beispiel, wenn aus dem einen Branch alle Änderungen an einer Datei per <code class="literal">git cherry-pick</code> (siehe <a class="xref" href="ch03.html#sec.cherry-pick" title="3.5. Einzelne Commits übernehmen: Cherry-Pick">Abschnitt 3.5, „Einzelne Commits übernehmen: Cherry-Pick“</a>) übernommen wurden. Der referenzierte Blob ist dann <span class="emphasis"><em>nicht</em></span> derselbe wie in der Merge-Basis.
</li>
            </ol>
          </div>
          <p>Wenn ein Tree-Eintrag in einem der Commits verschwindet, im anderen
aber noch vorhanden ist und <span class="emphasis"><em>der gleiche ist wie in der
Merge-Basis</em></span>, dann wird er nicht übernommen. Das entspricht
dem Löschen einer Datei oder eines Verzeichnisses, wenn an der Datei
auf der anderen Seite keine Änderungen vorgenommen wurden. Analog,
wenn ein Commit einen neuen Tree-Eintrag mitbringt, wird dieser in den
Merge-Tree übernommen.</p>
          <p>Was passiert nun, wenn eine Datei aus den Commits verschiedene Blobs
aufweist, die Datei also zumindest auf der einen Seite verändert
wurde? Im Falle, dass einer der Blobs der gleiche ist wie in der
Merge-Basis, wurden nur auf einer Seite Änderungen an der Datei
durchgeführt – Git kann diese Änderungen also einfach übernehmen.</p>
          <p>Wenn sich aber <span class="emphasis"><em>beide</em></span> Blobs von der Merge-Basis unterscheiden,
könnte es möglicherweise zu Problemen kommen.  Zunächst versucht Git,
die Änderungen beider Seiten zu übernehmen.</p>
          <p>Dafür wird in der Regel ein <span class="emphasis"><em>3-Wege-Merge</em></span>-Algorithmus verwendet.
Im Gegensatz zum klassischen 2-Wege-Merge-Algorithmus, der eingesetzt
wird, wenn Sie zwei unterschiedliche Versionen A und B einer Datei
haben und diese zusammenführen wollen, bezieht dieser
3-Wege-Algorithmus eine dritte Version C der Datei ein,
extrahiert aus obiger Merge-Basis. Der Algorithmus kann daher, weil
ein gemeinsamer Vorgänger der Datei bekannt ist, in vielen Fällen
besser (d.h. nicht nur anhand der Zeilennummer bzw. des Kontextes)
entscheiden, wie Änderungen zusammengeführt werden. In der Praxis
werden so viele trivial lösbare Merge-Konflikte schon automatisch ohne
Zutun des Nutzers gelöst.</p>
          <p>Es gibt allerdings Konflikte, die kein noch so guter Merge-Algorithmus
zusammenführen kann. Das passiert zum Beispiel, wenn in Version A der
Datei der Kontext direkt vor einer Änderung in Datei B geändert wurde,
oder, schlimmer noch, Version A und B und C unterschiedliche Versionen
einer Zeile aufweisen.</p>
          <p>Einen solchen Fall nennt man <span class="emphasis"><em>Merge-Konflikt</em></span>. Git führt
alle Dateien so gut es geht zusammen und präsentiert dem Nutzer
dann die in Konflikt stehenden Änderungen, damit dieser sie manuell
verschmelzen (und damit den Konflikt lösen) kann (siehe dafür <a class="xref" href="ch03.html#sec.merge-conflicts" title="3.4. Merge-Konflikte lösen">Abschnitt 3.4, „Merge-Konflikte lösen“</a>).</p>
          <p>Zwar ist es grundsätzlich möglich, mit einem speziell auf die
jeweilige Programmiersprache ausgerichteten Algorithmus eine
syntaktisch korrekte Auflösung zu erzeugen – allerdings kann ein
Algorithmus nicht hinter die <span class="emphasis"><em>Semantik</em></span> des Codes schauen, also
die Bedeutung des Codes erfassen. Daher wäre eine so generierte
Lösung in der Regel nicht sinnvoll.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.merge-ff"></a>3.3.2. Fast-Forward-Merges: Einen Branch vorspulen</h3>
              </div>
            </div>
          </div>
          <p>Das Kommando <code class="literal">git merge</code> erzeugt nicht immer einen
Merge-Commit. Ein trivialer Fall, der aber häufig vorkommt, ist der
sogenannte <span class="emphasis"><em>Fast-Forward-Merge</em></span>, also ein Vorspulen des Branches.</p>
          <p>Ein Fast-Forward-Merge tritt dann auf, wenn ein Branch, z.B. <code class="literal">topic</code>, Kind eines zweiten Branches, <code class="literal">master</code>,
ist:</p>
          <div class="figure">
            <a id="fig.merge-ff-before"></a>
            <p class="title">
              <strong>Abbildung 3.8. Vor dem <span class="emphasis"><em>Fast-Forward</em></span>-Merge</strong>
            </p>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="bilder_ebook/ff-vorher.png" width="486" alt="bilder_ebook/ff-vorher.png" />
              </div>
            </div>
          </div>
          <br class="figure-break" />
          <p>Ein einfaches <code class="literal">git merge topic</code> im Branch <code class="literal">master</code> führt
nun dazu, dass <code class="literal">master</code> einfach weitergerückt wird – es wird
kein Merge-Commit erzeugt.</p>
          <div class="figure">
            <a id="fig.merge-ff-after"></a>
            <p class="title">
              <strong>Abbildung 3.9. Nach dem <span class="emphasis"><em>Fast-Forward</em></span>-Merge – es wurde kein Merge-Commit erzeugt</strong>
            </p>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="bilder_ebook/ff-nachher.png" width="486" alt="bilder_ebook/ff-nachher.png" />
              </div>
            </div>
          </div>
          <br class="figure-break" />
          <p>Ein solches Verhalten geht natürlich nur dann, wenn die beiden
Branches nicht divergiert haben, wenn also die Merge-Basis beider
Branches einer der beiden Branches selbst ist, in diesem Falle
<code class="literal">master</code>.</p>
          <p>Dieses Verhalten ist häufig wünschenswert:</p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
Sie wollen Upstream-Änderungen, also Änderungen aus einem
  anderen Git-Repository, integrieren. Dafür verwenden Sie
  typischerweise ein Kommando wie <code class="literal">git merge origin/master</code>.
  Auch ein <code class="literal">git pull</code> wird einen Merge ausführen. Wie Sie
  Änderungen zwischen Git-Repositories austauschen, behandeln wir in
  <a class="xref" href="ch05.html" title="Kapitel 5. Verteiltes Git">Kapitel 5, <em>Verteiltes Git</em></a>.
</li>
              <li class="listitem">
Sie wollen einen experimentellen Branch einpflegen. Da Sie
  besonders einfach und schnell Branches in Git erstellen, empfiehlt
  es sich, für jedes Feature einen neuen Branch anzufangen.  Wenn Sie
  nun etwas Experimentelles auf einem Branch ausprobiert haben und
  dies integrieren wollen, ohne dass man einen „Zeitpunkt der
  Integration“ erkennen kann, dann geschieht das per
  <span class="emphasis"><em>Fast-Forward</em></span>.
</li>
            </ol>
          </div>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Mit den Optionen <code class="literal">--ff-only</code> und <code class="literal">--no-ff</code> können
Sie das Merge-Verhalten anpassen. Wenn Sie die erste Option verwenden
und die Branches können nicht per Fast-Forward zusammengeführt
werden, wird Git mit einer Fehlermeldung abbrechen. Die zweite
Option zwingt Git dazu, einen Merge-Commit zu erstellen, obwohl ein
Fast-Forward möglich gewesen wäre.</p>
          </div>
          <p>Es gibt verschiedene Meinungen, ob man Änderungen immer per
Fast-Forward integrieren sollte oder lieber einen Merge-Commit
erstellt, obwohl dies nicht unbedingt nötig ist. Die Resultate sind in
beiden Fällen gleich: Die Änderungen aus einem Branch werden in
einen anderen integriert.</p>
          <p>Wenn Sie allerdings einen Merge-Commit erstellen, dann wird die
<span class="emphasis"><em>Integration</em></span> eines Features deutlich. Betrachten Sie die beiden
folgenden Ausschnitte aus der Versionsgeschichte eines Projekts:</p>
          <div class="figure">
            <a id="fig.ff-vergleich"></a>
            <p class="title">
              <strong>Abbildung 3.10. Integration eines Features mit und ohne Fast-Forward</strong>
            </p>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="bilder_ebook/ff-no-ff-vergleich.png" width="432" alt="bilder_ebook/ff-no-ff-vergleich.png" />
              </div>
            </div>
          </div>
          <br class="figure-break" />
          <p>Im oberen Fall können Sie nicht ohne weiteres erkennen, welche
Commits ehemals im Branch <code class="literal">sha1-caching</code> entwickelt wurden,
also mit einem spezifischen Feature der Software zu tun haben.</p>
          <p>In der unteren Version jedoch können Sie auf den ersten Blick
erkennen, dass es genau vier Commits auf diesem Branch gab und er
dann integriert wurde. Da parallel nichts entwickelt wurde, wäre der
Merge-Commit prinzipiell unnötig, allerdings macht er die Integration
des Features deutlich.</p>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Es bietet sich daher an, statt auf die Magie von <code class="literal">git merge</code> zu
vertrauen, zwei Aliase (siehe auch <a class="xref" href="ch01.html#sec.git-alias" title="1.3.1. Git Aliase">Abschnitt 1.3.1, „Git Aliase“</a>) zu kreieren, die
einen Fast-Forward-Merge forcieren oder verbieten:</p>
            <pre class="screen">nfm = merge --no-ff     # no-ff-merge
ffm = merge --ff-only   #    ff-merge</pre>
          </div>
          <p>Ein expliziter Merge-Commit ist auch hilfreich, weil Sie diesen mit
einem einzigen Kommando rückgängig machen können.
Dies ist beispielsweise dann sinnvoll, wenn Sie einen Branch integriert
haben, der aber Fehler aufweist: Wenn der Code in Produktion läuft, ist
es häufig wünschenswert, die gesamte Änderung vorerst wieder auszubauen,
bis der Fehler korrigiert ist. Verwenden Sie dafür:</p>
          <pre class="screen">git revert -m 1 &lt;merge-commit&gt;</pre>
          <p>Git produziert dann einen neuen Commit, der alle Änderungen rückgängig
macht, die durch den Merge verursacht wurden. Die Option <code class="literal">-m 1</code> gibt
hier an, welche „Seite“ des Merges als <span class="emphasis"><em>Mainline</em></span>, also stabile
Entwicklungslinie, gelten soll: deren Änderungen bleiben bestehen.
Im obigen Beispiel würde <code class="literal">-m 1</code> dazu führen, dass die Änderungen der
vier Commits aus dem Branch <code class="literal">sha1-caching</code>, also dem zweiten Strang des
Merges, rückgängig gemacht würden.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.merge-strategies"></a>3.3.3. Merge-Strategien</h3>
              </div>
            </div>
          </div>
          <p>Git kennt fünf verschiedene Merge-Strategien, deren Verhalten
teilweise noch durch Strategie-Optionen weiter angepasst werden
kann. Die Strategie bestimmen Sie per <code class="literal">-s</code>, so dass ein
Merge-Aufruf  wie folgt lautet:</p>
          <pre class="screen">git merge -s &lt;strategie&gt; &lt;branch&gt;</pre>
          <p>Manche dieser Strategien können nur zwei Branches zusammenführen,
andere eine beliebige Anzahl.</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">resolve</code>
</span>
              </dt>
              <dd>
Die <code class="literal">resolve</code>-Strategie kann
    zwei Branches mit Hilfe einer 3-Wege-Merge-Technik zusammenführen.
    Als Merge-Basis wird dafür die neueste (beste) aller
    möglichen Basen verwendet. Diese Strategie ist schnell und erzeugt
    generell gute Ergebnisse.
</dd>
              <dt>
                <span class="term">
<code class="literal">recursive</code>
</span>
              </dt>
              <dd>
Dies ist die Standard-Strategie, die
    Git einsetzt, um zwei Branches zu verschmelzen. Auch hier wird ein
    3-Wege-Merge-Algorithmus eingesetzt. Allerdings geht diese
    Strategie geschickter vor als <code class="literal">resolve</code>: Existieren mehrere
    Merge-Basen, die allesamt „gleiche Berechtigung“
    haben,<a href="#ftn.idm45240358746640" class="footnote" id="idm45240358746640"><sup class="footnote">[39]</sup></a>
    dann führt Git zunächst diese Basen zusammen, um das Ergebnis dann
    als Merge-Basis für den 3-Wege-Merge-Algorithmus zu verwenden.
    Neben der Tatsache, dass dadurch auch Merges mit
    Dateiumbenennungen besser verarbeitet werden können, hat ein
    Testlauf auf der Versionsgeschichte des Linux-Kernels gezeigt,
    dass durch diese Strategien weniger Merge-Konflikte auftreten als
    mit der <code class="literal">resolve</code>-Strategie. Die Strategie kann durch
    diverse Optionen angepasst werden (s.u.).
</dd>
              <dt>
                <span class="term">
<code class="literal">octopus</code>
</span>
              </dt>
              <dd>
Standard-Strategie, wenn drei oder
    mehr Branches zusammengeführt werden. Die Octopus-Strategie kann
    im Gegensatz zu den beiden vorher genannten Strategien nur dann
    Merges durchführen, wenn kein Fehler auftritt, also keine manuelle
    Konfliktauflösung notwendig ist. Die Strategie ist besonders
    dafür gedacht, viele Topic-Branches, von denen bekannt ist, dass
    sie sich mit der Mainline (Haupt-Entwicklungsstrang) vertragen, zu
    integrieren.
</dd>
              <dt>
                <span class="term">
<code class="literal">ours</code>
</span>
              </dt>
              <dd>
Kann beliebig viele Branches
    verschmelzen, nutzt aber keinen Merge-Algorithmus. Stattdessen
    werden immer die Blobs bzw. Trees des aktuellen Branch (d.h.
    von dem Branch, von dem aus Sie <code class="literal">git merge</code> eingegeben
    haben) übernommen. Die Strategie wird vor allem dann verwendet,
    wenn Sie alte Entwicklungen mit dem aktuellen Stand der Dinge
    überschreiben wollen.
</dd>
              <dt>
                <span class="term">
<code class="literal">subtree</code>
</span>
              </dt>
              <dd>
Funktioniert wie <code class="literal">recursive</code>,
allerdings vergleicht die Strategie die Trees nicht „auf
gleicher Augenhöhe“, sondern bemüht sich, den Tree der einen
Seite als Subtree der anderen Seite zu finden und erst dann zu
verschmelzen. Diese Strategie ist zum Beispiel dann sinnvoll, wenn
Sie das Unterverzeichnis <code class="literal">Documentation/</code> Ihres Projekts
in einem separaten Repository verwalten. Dann können Sie die
Änderungen aus diesem Repository in das Haupt-Repository
übernehmen, indem Sie über  <code class="literal">git pull -s subtree
&lt;documentation-repo&gt;</code> die <code class="literal">subtree</code>-Strategie bemühen,
die die Inhalte von <code class="literal">&lt;documentation-repo&gt;</code> als
Unterverzeichnis des Haupt-Repositorys erkennt und den
Merge-Vorgang nur auf das entsprechende Unterverzeichnis anwendet.
Dieses Thema wird eingehender in <a class="xref" href="ch05.html#sec.subprojects" title="5.11. Unterprojekte verwalten">Abschnitt 5.11, „Unterprojekte verwalten“</a> behandelt.
</dd>
            </dl>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.recursive-options"></a>3.3.4. Optionen für die recursive-Strategie</h3>
              </div>
            </div>
          </div>
          <p>Die Default-Strategie <code class="literal">recursive</code> kennt mehrere Optionen, die das
Verhalten besonders bezüglich der Konfliktlösung anpassen. Sie
bestimmen sie über die Option <code class="literal">-X</code>; die Syntax lautet also:</p>
          <pre class="screen">git merge -s recursive -X &lt;option&gt; &lt;branch&gt;</pre>
          <p>Sofern Sie nur zwei Branches mergen, müssen Sie die
<code class="literal">recursive</code>-Strategie nicht explizit per <code class="literal">-s recursive</code>
angeben.</p>
          <p>Da die Strategie nur zwei Branches zusammenführen kann, ist es
möglich, von <span class="emphasis"><em>unserer</em></span> (engl. <span class="emphasis"><em>our</em></span>) und <span class="emphasis"><em>deren</em></span> (engl.
<span class="emphasis"><em>theirs</em></span>) Version zu sprechen: <span class="emphasis"><em>unsere</em></span> Version ist dabei
der ausgecheckte Branch beim Merge-Vorgang, während <span class="emphasis"><em>deren</em></span>
Version den Branch, den Sie integrieren wollen, referenziert.</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
<code class="literal">ours</code>
</span>
              </dt>
              <dd>
Wenn ein Merge-Konflikt auftritt, der
    normalerweise manuell gelöst werden müsste, wird stattdessen
    <span class="emphasis"><em>unsere</em></span> Version verwendet. Die Strategie-<span class="emphasis"><em>Option</em></span>
    unterscheidet sich allerdings von der <span class="emphasis"><em>Strategie</em></span> <code class="literal">ours</code>, denn dort werden jegliche Änderungen der
    Gegenseite(n) ignoriert. Die <code class="literal">ours</code>-Option hingegen
    übernimmt alle Änderungen unserer sowie der Gegenseite und gibt
    nur im Konfliktfall und nur an den Konfliktstellen
    <span class="emphasis"><em>unserer</em></span> Seite Vorrang.
</dd>
              <dt>
                <span class="term">
<code class="literal">theirs</code>
</span>
              </dt>
              <dd>
Wie <code class="literal">ours</code>, nur dass genau
    gegenteilig vorgegangen wird: bei Konflikten wird <span class="emphasis"><em>deren</em></span>
    Version bevorzugt.
</dd>
              <dt>
                <span class="term">
<code class="literal">ignore-space-change</code>, <code class="literal">ignore-all-space</code>, <code class="literal">ignore-space-at-eol</code>
</span>
              </dt>
              <dd>
                <p class="simpara">
Da Whitespace in den meisten Sprachen keine syntaktische Rolle spielt, können Sie mit diesen Optionen Git anweisen, im Falle eines Merge-Konfliktes zu probieren, ob dieser automatisch lösbar ist, wenn Whitespace keine Rolle spielt. Ein häufiger Anwendungsfall ist, dass ein Editor oder eine IDE Quellcode automatisch umformatiert hat.
</p>
                <p class="simpara">Die Option <code class="literal">ignore-space-at-eol</code> ignoriert Whitespace am Ende der
Zeile, was insbesondere dann hilfreich ist, wenn beide Seiten
verschiedene Zeilenende-Konventionen (LF/CRLF) verwenden. Geben
Sie <code class="literal">ignore-space-change</code> an, wird <span class="emphasis"><em>außerdem</em></span> Whitespace als reiner    Trenner betrachtet: Für den Vergleich einer Zeile ist also
unwesentlich, wie viele Leerzeichen oder Tabs an einer Stelle stehen – eingerückte Zeilen bleiben eingerückt, und getrennte Wörter
bleiben getrennt. Die Option <code class="literal">ignore-all-space</code> ignoriert jeglichen
Whitespace.</p>
                <p class="simpara">Generell geht die Strategie so vor: Falls <span class="emphasis"><em>deren</em></span> Version nur durch
die angegebene Option abgedeckte Whitespace-Änderungen hineinbringt,
werden diese ignoriert und <span class="emphasis"><em>unsere</em></span> Version verwendet; bringt sie
weitere Änderungen mit, und <span class="emphasis"><em>unsere</em></span> Version hat nur
Whitespace-Änderungen, so wird <span class="emphasis"><em>deren</em></span> Version verwendet. Wenn aber
auf beiden Seiten nicht nur Whitespace geändert wurde, so gibt es
weiterhin einen Merge-Konflikt.</p>
                <p class="simpara">Generell empfiehlt es sich nach einem Merge, den Sie nur mit Hilfe
einer dieser Optionen lösen konnten, die entsprechenden Dateien noch
einmal zu normalisieren, also die Zeilenenden und Einrückungen
einheitlich zu machen.</p>
              </dd>
              <dt>
                <span class="term">
<code class="literal">subtree=&lt;tree&gt;</code>
</span>
              </dt>
              <dd>
                <p class="simpara">
Ähnlich wie die
<code class="literal">subtree</code>-<span class="emphasis"><em>Strategie</em></span>, allerdings wird hier ein
expliziter Pfad angegeben. Analog zum obigen Beispiel würden Sie
</p>
                <pre class="screen">git pull -Xsubtree=Documentation &lt;documentation-repo&gt;</pre>
                <p class="simpara">verwenden.</p>
              </dd>
            </dl>
          </div>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="sec.merge-conflicts"></a>3.4. Merge-Konflikte lösen</h2>
            </div>
          </div>
        </div>
        <p>Wie bereits beschrieben, sind manche Konflikte nicht durch Algorithmen
aufzulösen – hier ist manuelle Nachbesserung nötig.  Gute
Team-Koordination sowie schnelle Integrationszyklen können größere
Merge-Konflikte minimieren. Aber gerade in der frühen Entwicklung,
wenn möglicherweise die Interna einer Software geändert werden, statt
neue Features hinzuzufügen, kann es zu Konflikten kommen.</p>
        <p>Wenn Sie in einem größeren Team arbeiten, dann ist in der Regel der
Entwickler, der maßgeblich am konfliktbehafteten Code gearbeitet hat,
dafür verantwortlich, eine Lösung zu finden. Eine solche
Konfliktlösung ist aber meist nicht schwierig, wenn der Entwickler
einen guten Überblick über die Software allgemein und insbesondere
über sein Stück Code und dessen Interaktion mit anderen Teilen
hat.</p>
        <p>Wir werden die Lösung eines Merge-Konflikts anhand eines einfachen
Beispiels in C durchgehen. Betrachten Sie die folgende Datei <code class="literal">output.c</code>:</p>
        <pre class="screen">int i;

for(i = 0; i &lt; nr_of_lines(); i++)
    output_line(i);

print_stats();</pre>
        <p>Das Stück Code geht alle Zeilen einer Ausgabe durch und gibt diese
nacheinander aus. Zuletzt liefert es eine kleine Statistik.</p>
        <p>Nun ändern zwei Entwickler etwas an diesem Code. Der erste,
Axel, schreibt eine Funktion, die die Zeilen umbricht, bevor sie
ausgegeben werden, und ersetzt im obigen Codestück
<code class="literal">output_line</code> durch seine verbesserte Version
<code class="literal">output_wrapped_line</code>:</p>
        <pre class="screen">int i;
int tw = 72;

for(i = 0; i &lt; nr_of_lines(); i++)
    output_wrapped_line(i, tw);

print_stats();</pre>
        <p>Die zweite Entwicklerin, Beatrice, modifiziert den Code, damit ihre
neu eingeführte Konfigurationseinstellung <code class="literal">max_output_lines</code>
honoriert wird, und nicht zu viele Zeilen ausgegeben werden:</p>
        <pre class="screen">int i;

for(i = 0; i &lt; nr_of_lines(); i++) {
    if(i &gt; config_get("max_output_lines"))
        break;
    output_line(i);
}

print_stats();</pre>
        <p>Beatrice verwendet also die „veraltete“ Version
<code class="literal">output_line</code>, und Axel hat noch nicht das Konstrukt, das die
Konfigurationseinstellung überprüft.</p>
        <p>Nun versucht Beatrice, ihre Änderungen auf Branch B in den
Branch <code class="literal">master</code> zu übernehmen, auf dem Axel seine Änderungen
 schon integriert hat:</p>
        <pre class="screen">$ <span class="strong"><strong>git checkout master</strong></span>
$ <span class="strong"><strong>git merge B</strong></span>
Auto-merging output.c
CONFLICT (content): Merge conflict in output.c
Automatic merge failed; fix conflicts and then commit the result.</pre>
        <p>In der Datei <code class="literal">output.c</code> platziert Git nun sogenannte
<span class="emphasis"><em>Konflikt-Marker</em></span>, unten halbfett hervorgehoben, die anzeigen, wo
sich Änderungen überschneiden. Es gibt zwei Seiten: Zum einen
<code class="literal">HEAD</code>, d.h. der Branch, in den Beatrice die Änderungen
übernehmen will – in diesem Falle <code class="literal">master</code>. Die andere Seite ist
der zu integrierende Branch – B. Die beiden Seiten werden
durch eine Reihe von Gleichheitszeichen voneinander getrennt:</p>
        <pre class="screen">int i;
int tw = 72;

<span class="strong"><strong>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</strong></span>
for(i = 0; i &lt; nr_of_lines(); i++)
    output_wrapped_line(i, tw);
<span class="strong"><strong>=======</strong></span>
for(i = 0; i &lt; nr_of_lines(); i++) {
    if(i &gt; config_get("max_output_lines"))
        break;
    output_line(i);
}
<span class="strong"><strong>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</strong></span>

print_stats();</pre>
        <p>Zu beachten ist hier, dass nur die wirklich <span class="emphasis"><em>konfliktbehafteten</em></span>
Änderungen von Beatrice beanstandet werden. Axels Definition von
<code class="literal">tw</code> weiter oben wird, obwohl bei Beatrice noch nicht
vorhanden, anstandslos übernommen.</p>
        <p>Beatrice muss nun den Konflikt lösen. Das passiert, indem sie zunächst
die Datei direkt editiert, den Code so abwandelt, wie er sein soll,
und anschließend die Konflikt-Marker entfernt. Wenn Axel in seiner
Commit-Nachricht entsprechend ausführlich dokumentiert hat<a href="#ftn.idm45240358670032" class="footnote" id="idm45240358670032"><sup class="footnote">[40]</sup></a>
wie seine neue Funktion arbeitet, sollte das schnell gehen:</p>
        <pre class="screen">int i;
int tw = 72;

for(i = 0; i &lt; nr_of_lines(); i++) {
    if(i &gt; config_get("max_output_lines"))
        break;
    output_wrapped_line(i, tw);
}

print_stats();</pre>
        <p>Anschließend muss Beatrice die Änderungen per <code class="literal">git add</code>
hinzufügen. Sofern keine Konflikt-Marker mehr in der Datei verbleiben,
ist dies für Git das Zeichen, dass ein Konflikt gelöst wurde.
Schließlich muss das Resultat noch eingecheckt werden:</p>
        <pre class="screen">$ <span class="strong"><strong>git add output.c</strong></span>
$ <span class="strong"><strong>git commit</strong></span></pre>
        <p>In der Commit-Nachricht sollte unbedingt stehen, wie dieser Konflikt
gelöst wurde. Auch mögliche Seiteneffekte auf andere Teile des
Programms sollten nicht unerwähnt bleiben.</p>
        <p>Normalerweise sind Merge-Commits „leer“, d.h. in
<code class="literal">git show</code> erscheint keine Diff-Ausgabe (weil die Änderungen ja
von anderen Commits verursacht wurden). Im Falle eines Merge-Commits,
der einen Konflikt löst, ist dies aber anders:</p>
        <pre class="screen">$ <span class="strong"><strong>git show</strong></span>
commit 6e6c55810c884356402c078f30e45a997047058e
Merge: f894659 256329f
Author: Beatrice &lt;beatrice@gitbu.ch&gt;
Date:   Mon Feb 28 05:59:36 2011 +0100

    Merge branch 'B'

    * B:
      honor max_output_lines config option

    Conflicts:
        output.c

diff --cc output.c
index a2bd8ed,f4c8bec..e39e39d
--- a/output.c
+++ b/output.c
@@@ -1,7 -1,9 +1,10 @@@
  int i;
 <span class="strong"><strong>+</strong></span>int tw = 72;

<span class="strong"><strong>-</strong></span> for(i = 0; i &lt; nr_of_lines(); i++)
<span class="strong"><strong>+</strong></span> for(i = 0; i &lt; nr_of_lines(); i++) {
<span class="strong"><strong>+</strong></span>     if(i &gt; config_get("max_output_lines"))
<span class="strong"><strong>+</strong></span>         break;
 <span class="strong"><strong>-</strong></span>    output_line(i);
 <span class="strong"><strong>+</strong></span>    output_wrapped_line(i, tw);
<span class="strong"><strong>+</strong></span> }

  print_stats();</pre>
        <p>Diese <span class="emphasis"><em>kombinierte</em></span> Diff-Ausgabe unterscheidet sich vom üblichen
Unidiff-Format: Es gibt nicht nur <span class="emphasis"><em>eine</em></span> Spalte mit den Markern für
hinzugefügt (<code class="literal">+</code>), entfernt (<code class="literal">-</code>) und Kontext bzw.
ungeändert (␣), sondern zwei. Git vergleicht also
das Resultat mit <span class="emphasis"><em>beiden</em></span> Vorfahren. Die in der zweiten Spalte
geänderten Zeilen entsprechen genau denen des Commits von Axel; die
(halbfett markierten) Änderungen in der ersten Spalte sind der Commit
von Beatrice inklusive Konfliktlösung.</p>
        <p>Der Standard-Weg, wie oben gesehen, ist der folgende:</p>
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
konfliktbehaftete Datei öffnen
</li>
            <li class="listitem">
Konflikt lösen, Marker entfernen
</li>
            <li class="listitem">
Datei per <code class="literal">git add</code> als „gelöst“ markieren
</li>
            <li class="listitem">
Schritt eins bis drei für alle Dateien wiederholen, in denen
  Konflikte auftraten
</li>
            <li class="listitem">
Konfliktlösungen per <code class="literal">git commit</code> einchecken
</li>
          </ol>
        </div>
        <p>Wenn Sie ad hoc nicht wissen, wie der Konflikt zu lösen ist (und zum
Beispiel den ursprünglichen Entwickler damit beauftragen wollen, eine
konfliktfreie Version des Codes zu produzieren), können Sie per
<code class="literal">git merge --abort</code> den Merge-Vorgang abbrechen – also den
Zustand Ihres Working Trees wieder auf den Stand bringen, auf dem er
war, bevor Sie den Merge-Vorgang angestoßen haben. Dieses Kommando
bricht auch einen Merge ab, den Sie schon teilweise gelöst haben.
Achtung: Dabei gehen alle nicht eingecheckten Änderungen verloren.</p>
        <div class="tip" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Tipp</h3>
          <p>Um einen Überblick zu erhalten, welche Commits für den
Merge-Konflikt relevante Änderungen an Ihrer Datei verursacht haben,
können Sie das Kommando</p>
          <pre class="screen">git log --merge -p -- &lt;datei&gt;</pre>
          <p>verwenden.  Git listet dann die Diffs von Commits auf, die seit der
Merge-Basis Änderungen an <code class="literal">&lt;datei&gt;</code> vorgenommen haben.</p>
        </div>
        <p>Wenn Sie sich in einem Merge-Konflikt befinden, liegt eine Datei mit
Konflikten in drei Stufen (<span class="emphasis"><em>Stages</em></span>) vor: Stufe eins enthält die
Version der Datei in der Merge-Basis (also die gemeinsame
Ursprungsversion der Datei), Stufe zwei enthält die Version aus dem
<code class="literal">HEAD</code> (also die Version aus dem Branch, <span class="emphasis"><em>in den</em></span> Sie
mergen). Stufe drei enthält schließlich die Datei in der Version des
zu integrierenden Branches (dieser hat die symbolische Referenz
<code class="literal">MERGE_HEAD</code>). Im Working Tree befindet sich die Kombination
dieser drei Stufen mit Konflikt-Markern. Sie können diese Versionen
aber jeweils mit <code class="literal">git show :&lt;n&gt;:&lt;datei&gt;</code> anzeigen:</p>
        <pre class="screen">$ <span class="strong"><strong>git show :1:output.c</strong></span>
$ <span class="strong"><strong>git show :2:output.c</strong></span>
$ <span class="strong"><strong>git show :3:output.c</strong></span></pre>
        <p>Mit einem speziell für 3-Wege-Merges entwickelten Programm behalten
Sie allerdings wesentlich leichter den Überblick. Das Programm
betrachtet die drei Stufen einer Datei, visualisiert sie entsprechend
und bietet Ihnen Möglichkeiten an, Änderungen hin- und herzuschieben.</p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.mergetool"></a>3.4.1. Hilfe beim Merge: mergetool</h3>
              </div>
            </div>
          </div>
          <p>Bei nicht-trivialen Merge-Konflikten empfiehlt sich ein Merge-Tool,
das die drei Stufen einer Datei entsprechend visualisiert und dadurch
die Lösung des Konflikts erleichtert.</p>
          <p>Gängige IDEs und Editoren wie z.B. Vim und Emacs bieten einen
solchen Modus an. Außerdem gibt es externe Tools, wie zum Beispiel
<span class="emphasis"><em>KDiff3</em></span>⁠<a href="#ftn.idm45240358627568" class="footnote" id="idm45240358627568"><sup class="footnote">[41]</sup></a>
und
<span class="emphasis"><em>Meld</em></span>⁠<a href="#ftn.idm45240358626304" class="footnote" id="idm45240358626304"><sup class="footnote">[42]</sup></a>.
Letzteres visualisiert besonders gut, wie sich eine Datei zwischen den
Commits verändert hat.</p>
          <div class="figure">
            <a id="fig.meld"></a>
            <p class="title">
              <strong>Abbildung 3.11. Der Beispiel-Merge-Konflikt, im Merge-Tool „Meld“ visualisiert</strong>
            </p>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="bilder_ebook/meld-example.png" width="540" alt="bilder_ebook/meld-example.png" />
              </div>
            </div>
          </div>
          <br class="figure-break" />
          <p>Sie starten ein solches Merge-Tool über <code class="literal">git mergetool</code>. Git wird alle
Dateien, die Konflikte enthalten, durchgehen und jeweils (wenn Sie
Eingabe drücken) in einem Merge-Tool anzeigen.  Per Default ist das
Vimdiff<a href="#ftn.idm45240358620736" class="footnote" id="idm45240358620736"><sup class="footnote">[43]</sup></a>.</p>
          <p>Ein solches Programm wird in der Regel die drei Versionen einer Datei – <span class="emphasis"><em>unsere</em></span> Seite, <span class="emphasis"><em>deren</em></span> Seite sowie die soweit wie
möglich zusammengeführte Datei inklusive Konflikt-Markern – in drei
Spalten nebeneinander anzeigen, letztere sinnvollerweise in der Mitte.
Wesentlich ist immer, dass Sie die Änderung (Konfliktlösung) in der
mittleren Datei machen, also auf der Working-Copy. Die anderen Dateien
sind temporär und werden wieder gelöscht, wenn das Merge-Tool beendet
wurde.</p>
          <p>Prinzipiell können Sie ein beliebiges anderes Tool verwenden. Das
<code class="literal">mergetool</code>-Script legt lediglich die drei Stufen der Datei mit
entsprechendem Dateinamen ab und startet das Diff-Tool auf diesen
drei Dateien. Beendet sich das Programm wieder, überprüft Git, ob noch
Konflikt-Marker in der Datei enthalten sind – wenn nicht, wird Git
annehmen, dass der Konflikt erfolgreich gelöst wurde, und die Datei
automatisch per <code class="literal">git add</code> dem Index hinzufügen. Wenn Sie also
alle Dateien abarbeiten, müssen Sie schließlich nur noch einen
Commit-Aufruf ausführen, um die Konfliktlösung zu besiegeln.</p>
          <p>Welches Tool Git auf der Datei startet, regelt die Option
<code class="literal">merge.tool</code>. Die folgenden Kommandos sind bereits
vorkonfiguriert, d.h. Git weiß bereits, in welcher Reihenfolge das
Programm die Argumente erwartet und welche Zusatzoptionen angegeben
werden müssen:</p>
          <pre class="screen">araxis bc3 codecompare deltawalker diffmerge diffuse
ecmerge emerge gvimdiff gvimdiff2 gvimdiff3 kdiff3
meld opendiff p4merge tkdiff tortoisemerge
vimdiff vimdiff2 vimdiff3 xxdiff</pre>
          <p>Um Ihr eigenes Merge-Tool zu verwenden, müssen Sie
<code class="literal">merge.tool</code> auf einen geeigneten Namen setzen, zum Beispiel
<code class="literal">mymerge</code>, und anschließend zumindest die Option
<code class="literal">mergetool.mymerge.cmd</code> angeben. Den darin gespeicherten
Ausdruck wertet die Shell aus, und die Variablen
<code class="literal">BASE</code>, <code class="literal">LOCAL</code>, <code class="literal">REMOTE</code> sowie <code class="literal">MERGED</code>,
die die Datei mit den Konflikt-Markern enthält, sind auf die
entsprechend erzeugten temporären Dateien gesetzt. Sie können die
Eigenschaften Ihres Merge-Kommandos weiter konfigurieren, siehe
dafür die Man-Page <code class="literal">git-config(1)</code> im Abschnitt der
<code class="literal">mergetool</code>-Konfiguration.</p>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Wenn Sie sich zeitweise (nicht dauerhaft) für ein
anderes Merge-Programm entscheiden, geben Sie dieses über die
Option <code class="literal">-t &lt;tool&gt;</code> an. Um also Meld auszuprobieren,
geben Sie während eines Merge-Konflikts einfach <code class="literal">git
mergetool -t meld</code> ein – dafür muss Meld natürlich installiert
sein.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.rerere"></a>3.4.2. rerere: Reuse Recorded Resolution</h3>
              </div>
            </div>
          </div>
          <p>Git besitzt ein relativ unbekanntes (und schlecht dokumentiertes),
aber sehr hilfreiches Feature: Rerere, kurz für <span class="emphasis"><em>Reuse Recorded
  Resolution</em></span> („gespeicherte Konfliktlösung
wiederverwenden“). Sie müssen die Option
<code class="literal">rerere.enabled</code> auf <code class="literal">true</code> setzen, damit das Kommando
automatisch aufgerufen wird (beachten Sie das <code class="literal">d</code> am Ende von
<code class="literal">enabled</code>).</p>
          <p>Die Idee hinter Rerere ist simpel, aber effektiv: Sobald ein
Merge-Konflikt auftritt, nimmt Rerere automatisch ein <span class="emphasis"><em>Preimage</em></span>
auf, ein Abbild der Konfliktdatei inklusive Markern. Im Falle des
obigen Beispiels sähe das so aus:</p>
          <pre class="screen">$ <span class="strong"><strong>git merge B</strong></span>
Auto-merging output.c
CONFLICT (content): Merge conflict in output.c
<span class="strong"><strong>Recorded preimage for 'output.c'</strong></span>
Automatic merge failed; fix conflicts and then commit the result.</pre>
          <p>Wird der Konflikt wie oben gelöst und die Lösung eingecheckt,
speichert Rerere die Konfliktlösung ab:</p>
          <pre class="screen">$ <span class="strong"><strong>vim output.c</strong></span>
$ <span class="strong"><strong>git add output.c</strong></span>
$ <span class="strong"><strong>git commit</strong></span>
<span class="strong"><strong>Recorded resolution for 'output.c'.</strong></span>
[master 681acc2] Merge branch 'B'</pre>
          <p>Bisher hat Rerere noch nicht wirklich geholfen. Jetzt aber können wir
den Merge-Commit komplett löschen (und sind wieder in der
Ausgangssituation vor dem Merge). Dann führen wir den Merge noch
einmal aus:</p>
          <pre class="screen">$ <span class="strong"><strong>git reset --hard HEAD^</strong></span>
HEAD is now at f894659 wrap output at 72 chars
$ <span class="strong"><strong>git merge B</strong></span>
Auto-merging output.c
CONFLICT (content): Merge conflict in output.c
<span class="strong"><strong>Resolved 'output.c' using previous resolution.</strong></span>
Automatic merge failed; fix conflicts and then commit the result.</pre>
          <p>Rerere bemerkt, dass der Konflikt bekannt ist und dass bereits eine
Lösung gefunden wurde.<a href="#ftn.idm45240358581552" class="footnote" id="idm45240358581552"><sup class="footnote">[44]</sup></a>
Also berechnet Rerere einen 3-Wege-Merge zwischen dem gespeicherten
Preimage, der gespeicherten Lösung und der im Working Tree
vorliegenden Version der Datei. So kann Rerere nicht nur dieselben
Konflikte lösen, sondern auch <span class="emphasis"><em>ähnliche</em></span> (wenn zwischenzeitlich
weitere Zeilen außerhalb des Konfliktbereichs geändert wurden).</p>
          <p>Das Ergebnis wird <span class="emphasis"><em>nicht</em></span> direkt dem Index hinzugefügt. Die
Lösung wird lediglich in die Datei übernommen. Sie können dann per
<code class="literal">git diff</code> nachschauen, ob die Lösung sinnvoll aussieht,
eventuell Tests laufen lassen etc. Wenn alles gut aussieht, übernehmen
Sie wie üblich die automatische Lösung per <code class="literal">git add</code>.</p>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.rerere-explained"></a>Warum Rerere sinnvoll ist</h4>
                </div>
              </div>
            </div>
            <p>Man könnte einwenden: Wer geht denn freiwillig das Risiko ein, einen
bereits (möglicherweise aufwendig) gelösten Merge-Konflikt zu löschen,
um ihn irgendwann wiederholen zu wollen?</p>
            <p>Das Vorgehen ist allerdings wünschenswert: Zunächst ist es
<span class="emphasis"><em>nicht</em></span> sinnvoll, einfach periodisch und aus Gewohnheit die
Mainline – also den Hauptentwicklungsstrang, z.B. <code class="literal">master</code> – in den Topic-Branch zu mergen (wir werden noch darauf
zurückkommen). Wenn Sie aber einen langlebigen Topic-Branch haben und
diesen gelegentlich darauf testen wollen, ob er sich mit der Mainline
verträgt, dann wollen Sie nicht jedes Mal die Konflikte von Hand
auflösen – einmal gelöste Konflikte wird Rerere dann automatisch
auflösen. Sie können so sukzessive Ihr Feature weiterentwickeln,
wohlwissend, dass es mit der Mainline in Konflikt steht.  Zum
Zeitpunkt der Integration des Features sind die Konflikte aber alle
automatisch lösbar (weil Sie gelegentlich Konfliktlösungen mit Rerere
abgespeichert haben).</p>
            <p>Außerdem wird Rerere auch automatisch in Konfliktfällen aufgerufen,
die in einem Rebase-Prozess (siehe <a class="xref" href="ch04.html#sec.rebase" title="4.1. Commits verschieben – Rebase">Abschnitt 4.1, „Commits verschieben – Rebase“</a>) entstehen.
Auch hier gilt wieder: Einmal gelöste Konflikte können automatisch
wieder gelöst werden. Wenn Sie einen Branch einmal testweise per Merge
in die Mainline integriert und einen Konflikt gelöst haben, wird diese
Lösung automatisch angewendet, wenn Sie diesen Branch per Rebase auf
die Mainline neu aufbauen.</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="sec.rerere-usage"></a>Rerere benutzen</h4>
                </div>
              </div>
            </div>
            <p>Damit die Rerere-Funktionalität verwendet wird, müssen Sie, wie schon
erwähnt, die Option <code class="literal">rerere.enabled</code> auf <code class="literal">true</code> setzen.
Rerere wird dann automatisch aufgerufen, wenn ein Merge-Konflikt
auftritt (um das Preimage aufzunehmen, möglicherweise auch um den
Konflikt zu lösen) und wenn eine Konfliktlösung eingecheckt wird (um
die Lösung abzuspeichern).</p>
            <p>Rerere legt Informationen wie Preimage und Lösung in
<code class="literal">.git/rr-cache/</code> ab, eindeutig identifiziert durch eine
SHA-1-Summe. Das Subkommando <code class="literal">git rerere</code> müssen Sie fast nie
aufrufen, da es von <code class="literal">merge</code> und <code class="literal">commit</code> schon erledigt
wird. Sie können analog zu <code class="literal">git gc</code> auch <code class="literal">git rerere gc</code>
verwenden, um sehr alte Lösungen zu löschen.</p>
            <p>Was passiert, wenn eine falsche Konfliktlösung eingecheckt wurde?
Dann sollten Sie die Konfliktlösung löschen, andernfalls wird Rerere
die Lösung, wenn Sie den konfliktbehafteten Merge wiederholen, erneut
anwenden. Dafür gibt es das Kommando <code class="literal">git rerere forget
  &lt;datei&gt;</code> – direkt nachdem Rerere eine falsche Lösung eingespielt
hat, können Sie auf diese Weise die falsche Lösung löschen und den
Ursprungszustand der Datei wiederherstellen (d.h.  mit
Konflikt-Markern). Wollen Sie nur Letzteres bewirken, hilft auch ein
<code class="literal">git checkout -m &lt;datei&gt;</code>.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.avoid-conflicts"></a>3.4.3. Konflikte vermeiden</h3>
              </div>
            </div>
          </div>
          <p>Dezentrale Versionskontrollsysteme verwalten Merges generell
wesentlich besser als zentrale. Das liegt vor allem daran,
dass es bei dezentralen Systemen Usus ist, viele kleine Änderungen
zunächst <span class="emphasis"><em>lokal</em></span> einzuchecken. Dadurch entstehen keine
„Monster-Commits“, die wesentlich mehr
Konfliktpotential bieten. Diese feiner granulierte
Entwicklungsgeschichte und der Umstand, dass Merges in der Regel
wiederum Daten in der Versionsgeschichte sind (im Gegensatz zu einem
simplen Kopieren der Codezeilen), führen dazu, dass dezentrale Systeme
bei einem Merge nicht nur auf den bloßen Inhalt von Dateien schauen
müssen.</p>
          <p>Um Merge-Konflikte zu minimieren, ist Vorbeugung das beste Mittel.
Machen Sie kleine Commits! Fassen Sie Ihre Änderungen so zusammen,
dass der resultierende Commit als Einheit Sinn ergibt. Bauen Sie
Topic-Branches immer auf dem neuesten Release auf. Mergen Sie von
Topic-Branches in „Sammel-Branches“ oder direkt in den
<code class="literal">master</code>, nicht anders
herum.<a href="#ftn.idm45240358554480" class="footnote" id="idm45240358554480"><sup class="footnote">[45]</sup></a> Der
Einsatz von Rerere erlaubt es, dass bereits gelöste Konflikte nicht
ständig erneut auftreten.</p>
          <p>Offensichtlich zählt zur Vorbeugung auch gute Kommunikation unter den
Entwicklern: Wenn mehrere Entwickler an der gleichen Funktion
unterschiedliche und sich gegenseitig beeinflussende Änderungen
implementieren, wird das früher oder später sicher zu Konflikten
führen.</p>
          <p>Ein weiterer Faktor, der leider häufig zu unnötigen(!) Konflikten
führt, sind autogenerierte Inhalte. Angenommen, Sie schreiben die
Dokumentation einer Software in
<span class="emphasis"><em>AsciiDoc</em></span>⁠<a href="#ftn.idm45240358551184" class="footnote" id="idm45240358551184"><sup class="footnote">[46]</sup></a>
oder arbeiten an einem
LaTeX-Projekt mit mehreren Mitstreitern: Fügen Sie keinesfalls die
kompilierten Man-Pages oder das kompilierte DVI/PS/PDF im Repository
ein! In den autogenerierten Formaten können kleine Änderungen am
Plaintext (d.h. in der Ascii- bzw. LaTeX-Version) große (und
unvorhersehbare) Änderungen an den kompilierten Formaten hervorrufen,
die Git nicht adäquat auflösen wird. Sinnvoll ist es stattdessen,
entsprechende Makefile-Targets oder Scripte bereitzustellen, um die
Dateien zu generieren, und möglicherweise die kompilierte
Version auf einem separaten Branch vorzuhalten.<a href="#ftn.idm45240358548864" class="footnote" id="idm45240358548864"><sup class="footnote">[47]</sup></a></p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="sec.cherry-pick"></a>3.5. Einzelne Commits übernehmen: Cherry-Pick</h2>
            </div>
          </div>
        </div>
        <p>Es wird vorkommen, dass Sie nicht direkt einen ganzen Branch
integrieren wollen, sondern zunächst Teile, also einzelne Commits.
Dafür ist das Git-Kommando <code class="literal">cherry-pick</code> („die guten
Kirschen herauspicken“) zuständig.</p>
        <p>Das Kommando erwartet einen oder mehrere Commits, die auf den aktuellen
Branch kopiert werden sollen. Zum Beispiel:</p>
        <pre class="screen">$ <span class="strong"><strong>git cherry-pick d0c915d</strong></span>
$ <span class="strong"><strong>git cherry-pick topic~5 topic~1</strong></span>
$ <span class="strong"><strong>git cherry-pick topic~5..topic~1</strong></span></pre>
        <p>Das mittlere Kommando kopiert zwei explizit angegebene Commits; das
letzte Kommando hingegen kopiert alle zu der angegebenen Commit-Range
gehörigen Commits.</p>
        <p>Im Gegensatz zu einem Merge werden aber nur die Änderungen integriert,
nicht der Commit selbst. Dafür müsste er nämlich seinen Vorgänger
referenzieren, so dass dieser auch integriert werden müsste usw. – was einem Merge gleichkommt. Wenn Sie Commits mit <code class="literal">cherry-pick</code>
übernehmen, entstehen dabei also <span class="emphasis"><em>neue</em></span> Commits mit neuer
Commit-ID. Git kann danach <span class="emphasis"><em>nicht</em></span> ohne weiteres wissen, dass
diese Commits eigentlich die gleichen sind.</p>
        <p>Daher kann es, wenn Sie zwei Branches mergen, zwischen denen Sie
Änderungen per Cherry-Pick ausgetauscht haben, zu Konflikten kommen.<a href="#ftn.idm45240358537216" class="footnote" id="idm45240358537216"><sup class="footnote">[48]</sup></a>  Diese
sind meist trivial zu lösen, möglicherweise sind auch die
Strategie-Optionen <code class="literal">ours</code> bzw. <code class="literal">theirs</code> hilfreich
(siehe <a class="xref" href="ch03.html#sec.recursive-options" title="3.3.4. Optionen für die recursive-Strategie">Abschnitt 3.3.4, „Optionen für die recursive-Strategie“</a>).
Das Rebase-Kommando hingegen erkennt solche Commit-Doppelungen,<a href="#ftn.idm45240358533344" class="footnote" id="idm45240358533344"><sup class="footnote">[49]</sup></a>
und lässt die gedoppelten Commits aus. So können Sie einige Commits
„aus der Mitte“ übernehmen und dann den Branch, aus dem die
Commits stammten, neu aufbauen.</p>
        <p>Das <code class="literal">cherry-pick</code>-Kommando versteht außerdem selbst diese
Merge-Strategie-Optionen: Wenn Sie einen Commit in den aktuellen Branch
kopieren wollen, und im Konfliktfall dem neuen Commit recht geben
wollen, verwenden Sie:</p>
        <pre class="screen">git cherry-pick -Xtheirs &lt;commit&gt;</pre>
        <div class="tip" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Tipp</h3>
          <p>Über die Option <code class="literal">-n</code> bzw. <code class="literal">--no-commit</code> veranlassen
Sie Git, die Änderungen eines Commits zwar in den Index zu
übernehmen, aber noch keinen Commit daraus zu machen. So können Sie
mehrere kleine Commits erst im Index „aggregieren“ und
dann als <span class="emphasis"><em>einen</em></span> Commit verpacken:</p>
          <pre class="screen">$ <span class="strong"><strong>git cherry-pick -n 785aa39 512f3e9 4e4a063</strong></span>
Finished one cherry-pick.
Finished one cherry-pick.
Finished one cherry-pick.
$ <span class="strong"><strong>git commit -m "Diverse kleine Änderungen"</strong></span></pre>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="sec.visualization"></a>3.6. Visualisierung von Repositories</h2>
            </div>
          </div>
        </div>
        <p>Wenn Sie einige Branches erstellt und wieder zusammengeführt haben,
werden Sie gemerkt haben: Man verliert leicht den Überblick.</p>
        <p>Die Anordnung der Commits und ihre Beziehungen untereinander
bezeichnet man als <span class="emphasis"><em>Topologie</em></span> eines Repositorys. Im Folgenden
werden wir unter anderem das grafische Programm <code class="literal">gitk</code>
vorstellen, um diese Topologien zu untersuchen.</p>
        <p>Rufen Sie bei kleinen Repositories zunächst ganz einfach <code class="literal">gitk
  --all</code> auf, das das komplette Repository als Graphen darstellt. Ein
Klick auf die einzelnen Commits zeigt die Metainformationen sowie den
erzeugten Patch an.</p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="rev-list"></a>3.6.1. Revision Parameters</h3>
              </div>
            </div>
          </div>
          <p>Da die Auflistung mehrerer Commits kaum zu überblicken ist,
untersuchen wir ein kleines Beispiel-Repository mit mehreren Branches,
die untereinander gemergt wurden:</p>
          <div class="figure">
            <a id="fig.rev-list-graph"></a>
            <p class="title">
              <strong>Abbildung 3.12. Der Graph der Commits, wie er in <code class="literal">gitk</code> dargestellt wird</strong>
            </p>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="bilder_ebook/revision-list-commit-graph-gitk.png" width="486" alt="bilder_ebook/revision-list-commit-graph-gitk.png" />
              </div>
            </div>
          </div>
          <br class="figure-break" />
          <p>Wir erkennen vier Branches (A-D) sowie einen Tag <code class="literal">release</code>.
Diesen Baum können wir mit geeigneten Kommandozeilenoptionen auch per
<code class="literal">log</code>-Kommando auf der Konsole anzeigen lassen (Branch- und
Tag-Namen sind zur besseren Unterscheidung halbfett gedruckt):</p>
          <pre class="screen">$ <span class="strong"><strong>git log --decorate --pretty=oneline --abbrev-commit --graph --all</strong></span>
* c937566 (<span class="strong"><strong>HEAD</strong></span>, <span class="strong"><strong>D</strong></span>) commit on branch D
| *   b0b30ef (<span class="strong"><strong>release</strong></span>, <span class="strong"><strong>A</strong></span>) Merge branch 'C' into A
| |\
| | * 807db47 (<span class="strong"><strong>C</strong></span>) commit on branch C
| | * 996a53b commit on branch C
| |/
|/|
| * 83f6bf3 commit on branch A
| *   5b2c291 Merge branch 'B' into A
| |\
| | * 2417cf7 (<span class="strong"><strong>B</strong></span>) commit on branch B
| |/
|/|
| * 0bf1433 commit on branch A
|/
* 4783886 initial commit</pre>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Die Ausgabe des <code class="literal">log</code>-Kommandos ist äquivalent zu der Ansicht
in Gitk. Allerdings ist <code class="literal">git log</code> sehr viel schneller als
Gitk und kommt ohne ein weiteres Programmfenster aus.</p>
            <p>Für eine schnelle Übersicht ist es also viel praktischer, ein
Alias einzurichten, das die vielen langen Optionen automatisch
hinzufügt. Die Autoren verwenden dafür das Alias <code class="literal">tree</code>, das
Sie wie folgt definieren können:</p>
            <pre class="screen">$ <span class="strong"><strong>git config --global alias.tree 'log --decorate \</strong></span>
   <span class="strong"><strong>--pretty=oneline --abbrev-commit --graph'</strong></span></pre>
            <p>Per <code class="literal">git tree --all</code> erhalten Sie eine ASCII-Version des
Graphen des Git-Repositorys. Im Folgenden nutzen wir dieses Alias, um
die Topologie darzustellen.</p>
          </div>
          <p>Nun verändern wir obiges Kommando: Statt der Option <code class="literal">--all</code>,
die alle Commits im Baum unterbringt, geben wir nun <code class="literal">B</code> an (den
Namen des Branch):</p>
          <pre class="screen">$ <span class="strong"><strong>git tree B</strong></span>
* 2417cf7 (<span class="strong"><strong>B</strong></span>) commit on branch B
* 4783886 initial commit</pre>
          <p>Wir erhalten alle Commits, die von B aus erreichbar sind. Ein
Commit kennt jeweils nur seinen bzw. seine Vorgänger (mehrere dann,
wenn Branches zusammengeführt werden).  „Alle von B erreichbaren
Commits“ bezeichnet also die Liste der Commits von B an weiter
bis zu einem Commit, der keinen Vorgänger hat (genannt
<span class="emphasis"><em>Root-Commit</em></span>).</p>
          <p>Statt einer kann das Kommando auch mehrere Referenzen entgegennehmen.
Um also die gleiche Ausgabe wie mit der Option <code class="literal">--all</code> zu
erhalten, müssen Sie die Referenzen A, B und D angeben. C kann
ausgelassen werden, weil der Commit auf dem Weg von A zum Root-Commit
bereits „eingesammelt“ wird.</p>
          <p>Natürlich können Sie statt symbolischer Referenzen auch direkt eine
SHA-1-Summe angeben:</p>
          <pre class="screen">$ <span class="strong"><strong>git tree 5b2c291</strong></span>
*   5b2c291 Merge branch 'B' into A
|\
| * 2417cf7 (<span class="strong"><strong>B</strong></span>) commit on branch B
* | 0bf1433 commit on branch A
|/
* 4783886 initial commit</pre>
          <p>Wird einer Referenz ein Caret (<code class="literal">^</code>) vorangestellt, so negiert das
die Bedeutung.<a href="#ftn.idm45240358487792" class="footnote" id="idm45240358487792"><sup class="footnote">[50]</sup></a>  Die Notation <code class="literal">^A</code> bedeutet also: <span class="emphasis"><em>nicht</em></span> die Commits,
die von A aus erreichbar sind. Allerdings schließt dieser Schalter
lediglich diese Commits aus, nicht jedoch die anderen ein.  Obiges
<code class="literal">log</code>-Kommando mit dem Argument <code class="literal">^A</code> wird also nichts ausgeben, da Git
nur weiß, welche Commits <span class="emphasis"><em>nicht</em></span> angezeigt werden sollen. Wir fügen
also wieder <code class="literal">--all</code> hinzu, um alle Commits aufzulisten, abzüglich
derer, die von A erreichbar sind:</p>
          <pre class="screen">$ <span class="strong"><strong>git tree --all ^A</strong></span>
* c937566 (<span class="strong"><strong>HEAD</strong></span>, <span class="strong"><strong>D</strong></span>) commit on branch D</pre>
          <p>Eine alternative Notation ist mit <code class="literal">--not</code> verfügbar: Statt
<code class="literal">^A</code> kann man auch <code class="literal">--not A</code> schreiben.</p>
          <p>Besonders hilfreich sind solche Kommandos, um den <span class="emphasis"><em>Unterschied</em></span>
zwischen zwei Branches zu untersuchen: Welche Commits sind in Branch
D, die nicht in A sind?  Die Antwort liefert das Kommando:</p>
          <pre class="screen">$ <span class="strong"><strong>git tree D ^A</strong></span>
* c937566 (<span class="strong"><strong>HEAD</strong></span>, <span class="strong"><strong>D</strong></span>) commit on branch D</pre>
          <p>Weil sich diese Frage häufig stellt, gibt es dafür eine andere,
intuitivere Notation: <code class="literal">A..D</code> ist gleichbedeutend mit <code class="literal">D ^A</code>:</p>
          <pre class="screen">$ <span class="strong"><strong>git tree A..D</strong></span>
* c937566 (<span class="strong"><strong>HEAD</strong></span>, <span class="strong"><strong>D</strong></span>) commit on branch D</pre>
          <p>Natürlich ist hier die Reihenfolge wichtig: „D ohne A“ ist
eine andere Menge von Commits als „A ohne D“! (Vergleiche
auch den vollständigen Graphen.)</p>
          <p>Im unserem Beispiel gibt es einen Tag <code class="literal">release</code>. Um zu
überprüfen, welche Commits aus dem Branch D (der für
„Development“ stehen könnte) noch nicht im aktuellen Release
enthalten sind, genügt die Angabe <code class="literal">release..D</code>.</p>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Die Syntax <code class="literal">A..B</code> kann man sich als Idiom „von
A bis B“ merken. Diese „Differenz“
ist aber nicht symmetrisch, d.h. <code class="literal">A..B</code> sind in der Regel
nicht die gleichen Commits wie <code class="literal">B..A</code>.</p>
            <p>Alternativ stellt Git die <span class="emphasis"><em>symmetrische Differenz</em></span> <code class="literal">A...B</code> bereit. Sie entspricht dem Argument <code class="literal">A B
    --not $(git merge-base A B)</code>, bezieht also alle Commits ein,
  die von A <span class="emphasis"><em>oder</em></span> von B erreichbar sind – aber nicht von beiden.</p>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="rev-list-explained"></a>Referenz vs. Liste von Referenzen</h4>
                </div>
              </div>
            </div>
            <p>Im Beispiel werden mit A immer alle Commits bezeichnet, die von A
erreichbar sind. Aber eigentlich ist ein Branch ja nur eine Referenz
auf <span class="emphasis"><em>einen</em></span> Commit. Warum listet also <code class="literal">log</code> immer alle von
A erreichbaren Commits auf, während das Git-Kommando
<code class="literal">show</code> mit dem Argument <code class="literal">A</code> nur diesen einen Commit
anzeigt?</p>
            <p>Der Unterschied liegt darin, was die Kommandos als Argument erwarten:
<code class="literal">show</code> erwartet ein <span class="emphasis"><em>Objekt</em></span>, also eine Referenz auf
<span class="emphasis"><em>ein</em></span> Objekt, das dann angezeigt wird.<a href="#ftn.idm45240358453040" class="footnote" id="idm45240358453040"><sup class="footnote">[51]</sup></a>
Viele andere Kommandos erwarten stattdessen einen (oder auch mehrere)
<span class="emphasis"><em>Commits</em></span>, und diese Kommandos wandeln die Argumente in eine
Liste von Commits um (traversieren die Liste bis zum Root-Commit).</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="sec.gitk"></a>3.6.2. Gitk</h3>
              </div>
            </div>
          </div>
          <p>Gitk ist ein in Tcl implementiertes grafisches Programm, das in der
Regel von Distributoren zusammen mit den eigentlichen Git-Kommandos
paketiert wird – Sie können sich also darauf verlassen, es auf fast
jedem System vorzufinden.</p>
          <p>Es repräsentiert einzelne Commits oder das ganze Repository in einer
dreiteiligen Ansicht: Oben die Baumstruktur mit zwei weiteren Spalten
für Autor und Datum, unten eine Auflistung der Änderungen im
Unified-Diff-Format sowie eine Liste von Dateien, um die angezeigten
Änderungen einzuschränken.</p>
          <p>Die Graph-Ansicht ist intuitiv: Verschiedene Farben helfen, die
verschiedenen Versionsstränge zu unterscheiden. Commits sind jeweils
blaue Punkte, mit zwei Ausnahmen: Der <code class="literal">HEAD</code> ist gelb markiert,
und ein Commit, der nicht Root-Commit ist, dessen Vorgänger aber nicht
angezeigt ist, wird weiß dargestellt.</p>
          <p>Branches mit einer Pfeilspitze deuten an, dass auf dem
Branch weitere Commits getätigt wurden. Aufgrund der zeitlichen
Distanz der Commits blendet Gitk aber den Branch aus. Ein Klick auf
die Pfeilspitze bringt Sie zu der Weiterführung des Branches.</p>
          <p>Branches erscheinen als grüne Labels, der aktuell ausgecheckte Branch
zusätzlich fett. Tags sind als gelbe Pfeile dargestellt.</p>
          <p>Mit einem Rechtsklick auf einen Branch können Sie diesen löschen oder
auschecken. Auf Commits öffnet ein Rechtsklick ein Menü, in dem Sie
Aktionen mit dem markierten Commit ausführen können. Die einzige, die
mit Gitk möglicherweise leichter zu bewerkstelligen ist als über die
Kommandozeile, ist <span class="emphasis"><em>Cherry-Picking</em></span>, also das Übernehmen
einzelner Commits in einen anderen Branch (siehe auch
<a class="xref" href="ch03.html#sec.cherry-pick" title="3.5. Einzelne Commits übernehmen: Cherry-Pick">Abschnitt 3.5, „Einzelne Commits übernehmen: Cherry-Pick“</a>).</p>
          <div class="figure">
            <a id="fig.gitk"></a>
            <p class="title">
              <strong>Abbildung 3.13. Komplizierte Topologie in Gitk</strong>
            </p>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="bilder_ebook/gitk.png" width="486" alt="bilder_ebook/gitk.png" />
              </div>
            </div>
          </div>
          <br class="figure-break" />
          <p>Gitk akzeptiert im wesentlichen die gleichen Optionen wie <code class="literal">git
  log</code>. Einige Beispiele:</p>
          <pre class="screen">$ <span class="strong"><strong>gitk --since=yesterday -- doc/</strong></span>
$ <span class="strong"><strong>gitk e13404a..48effd3</strong></span>
$ <span class="strong"><strong>gitk --all -n 100</strong></span></pre>
          <p>Das erste Kommando zeigt alle Commits seit gestern an, die Änderungen
an einer Datei unterhalb des Verzeichnisses <code class="literal">doc/</code> vorgenommen
haben. Das zweite Kommando limitiert die Commits auf eine spezielle
Range, während das dritte Kommando die 100 neuesten Commits aller
Branches anzeigt.</p>
          <div class="tip" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Tipp</h3>
            <p>Erfahrungsgemäß sind Anfänger oft verwirrt, weil <code class="literal">gitk</code>
standardmäßig nur den aktuellen Branch anzeigt. Das liegt vermutlich
daran, dass <code class="literal">gitk</code> oft aufgerufen wird, um sich einen
Überblick aller Branches zu verschaffen.  Daher bietet sich
folgendes Shell-Alias an: <code class="literal">alias gik='gitk --all'</code></p>
          </div>
          <p>Viele Nutzer lassen <code class="literal">gitk</code> während der Arbeit offen. Dann ist
es wichtig, von Zeit zu Zeit die Anzeige zu aktualisieren, damit auch
aktuellere Commits erscheinen. Mit <span class="emphasis"><em>F5</em></span> (<span class="emphasis"><em>Update</em></span>) laden
Sie alle neuen Commits und erneuern die Darstellung der Referenzen.
Manchmal, wenn Sie z.B. einen Branch löschen, reicht dies jedoch
nicht aus. Zwar wird der Branch nicht mehr angezeigt, aber evtl. sind
unerreichbare Commits weiterhin quasi als Artefakte in der GUI
vorhanden. Mit der Tastenkombination <span class="emphasis"><em>Strg+F5</em></span>
(<span class="emphasis"><em>Reload</em></span>) wird das Repository vollständig neu eingelesen, was
das Problem beseitigt.</p>
          <p>Alternativ zu <code class="literal">gitk</code> können Sie auf UNIX-Systemen das GTK-basierte
<code class="literal">gitg</code> oder Qt-basierte <code class="literal">qgit</code> verwenden; auf einem OS-X-System können
Sie beispielsweise <span class="emphasis"><em>GitX</em></span> verwenden; für Windows bieten sich die
<span class="emphasis"><em>GitExtensions</em></span> an. Einige IDEs verfügen mittlerweile auch über
entsprechende Visualisierungen (z.B. das <span class="emphasis"><em>Eclipse</em></span>-Plugin <span class="emphasis"><em>EGit</em></span>).
Weiterhin können Sie vollwertige Git-Clients wie <span class="emphasis"><em>Atlassian SourceTree</em></span>
(OS X, Windows; kostenlos), <span class="emphasis"><em>Tower</em></span> (OS X; kommerziell) sowie <span class="emphasis"><em>SmartGit</em></span>
(Linux, OS X und Windows; kostenlos für nichtkommerzielle Nutzung)
verwenden.</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="sec.reflog"></a>3.7. Reflog</h2>
            </div>
          </div>
        </div>
        <p>Das <span class="emphasis"><em>Reference Log</em></span> (<span class="emphasis"><em>Reflog</em></span>) sind Log-Dateien, die Git für
jeden Branch sowie <code class="literal">HEAD</code> anlegt. Darin wird gespeichert, wann
eine Referenz von wo nach wo verschoben wurde. Das passiert vor allem
bei den Kommandos <code class="literal">checkout</code>, <code class="literal">reset</code>, <code class="literal">merge</code>
und <code class="literal">rebase</code>.</p>
        <p>Diese Log-Dateien liegen unter <code class="literal">.git/logs/</code> und tragen den
Namen der jeweiligen Referenz. Das Reflog für den
<code class="literal">master</code>-Branch finden Sie also unter
<code class="literal">.git/logs/refs/heads/master</code>. Außerdem gibt es das Kommando
<code class="literal">git reflog show &lt;referenz&gt;</code>, um das Reflog aufzulisten:</p>
        <pre class="screen">$ <span class="strong"><strong>git reflog show master</strong></span>
48effd3 master@{0}: HEAD^: updating HEAD
ef51665 master@{1}: rebase -i (finish): refs/heads/master onto 69b9e27
231d0a3 master@{2}: merge @{u}: Fast-forward
...</pre>
        <p>Das Reflog-Kommando wird selten direkt benutzt und ist nur ein Alias
für <code class="literal">git log -g --oneline</code>. Die Option <code class="literal">-g</code> bewirkt
nämlich, dass das Kommando nicht die Vorgänger im Commit-Graphen
anzeigt, sondern die Commits in der Reihenfolge des Reflogs
abarbeitet.</p>
        <p>Das können Sie ganz leicht ausprobieren: Erstellen Sie einen
Test-Commit und löschen Sie ihn danach wieder mit <code class="literal">git reset
  --hard HEAD^</code>. Das Kommando <code class="literal">git log -g</code> wird nun zuerst
den <code class="literal">HEAD</code> anzeigen, dann den gelöschten Commit und dann wieder
den <code class="literal">HEAD</code>.</p>
        <p>Das Reflog referenziert also auch Commits, die sonst nicht mehr
referenziert sind, also „verloren“ sind (siehe
<a class="xref" href="ch03.html#sec.branch-management" title="3.1.2. Branches verwalten">Abschnitt 3.1.2, „Branches verwalten“</a>). So hilft das Reflog Ihnen
möglicherweise, wenn Sie einen Branch gelöscht haben, von dem sich im
Nachhinein herausstellt, dass Sie ihn doch gebraucht hätten. Zwar
löscht ein <code class="literal">git branch -D</code> auch das Reflog des Branches.
Allerdings haben Sie den Branch ja auschecken müssen, um Commits
darauf zu machen: Suchen Sie also mit <code class="literal">git log -g HEAD</code> nach
dem letzten Zeitpunkt, zu dem Sie den gesuchten Branch ausgecheckt
haben. Dann erstellen Sie einen Branch, der auf diese (scheinbar
verlorene) Commit-ID zeigt, und Ihre verlorenen Commits sollten wieder
da sein.<a href="#ftn.idm45240358403344" class="footnote" id="idm45240358403344"><sup class="footnote">[52]</sup></a></p>
        <p>Kommandos, die eine oder mehrere Referenzen erwarten, können
allerdings auch implizit das Reflog verwenden. Neben der Syntax, die
sich schon bei der Ausgabe von <code class="literal">git log -g</code> findet (z.B. <code class="literal">HEAD@{1}</code> für die vorherige Position des <code class="literal">HEAD</code>),
versteht Git auch <code class="literal">&lt;ref&gt;@{&lt;wann&gt;}</code>.  Git interpretiert den
Zeitpunkt <code class="literal">&lt;wann&gt;</code> als absolutes oder relatives Datum und
konsultiert dann das Reflog der entsprechenden Referenz, um
herauszufinden, was der zeitlich nächste Log-Eintrag ist. Dieser wird
dann referenziert.</p>
        <p>Zwei Beispiele:</p>
        <pre class="screen">$ <span class="strong"><strong>git log 'master@{two weeks ago}..'</strong></span>
$ <span class="strong"><strong>git show '@{1st of April, 2011}'</strong></span></pre>
        <p>Das erste Kommando listet alle Commits zwischen <code class="literal">HEAD</code> und dem
Commit auf, auf den der <code class="literal">master</code>-Branch vor zwei Wochen gezeigt
hat (beachten Sie das Suffix <code class="literal">..</code>, was eine Commit-Range bis
<code class="literal">HEAD</code> bedeutet). Das muss nicht nötigerweise auch ein Commit
sein, der zwei Wochen alt ist: Wenn Sie vor zwei Wochen testweise per
<code class="literal">git reset --hard &lt;initial-commit&gt;</code> den Branch auf den
allerersten Commit des Repositorys verschoben haben, dann wird genau
dieser Commit referenziert.<a href="#ftn.idm45240358390608" class="footnote" id="idm45240358390608"><sup class="footnote">[53]</sup></a></p>
        <p>Die zweite Zeile zeigt den Commit an, auf den der (wegen fehlender
expliziter Referenz vor dem <code class="literal">@</code>) aktuell ausgecheckte Branch am
1. April 2011 gezeigt hat. In beiden Kommandos muss das Argument mit
Reflog-Anhang sinnvoll in Anführungszeichen eingefasst werden, damit
Git das Argument komplett erhält.</p>
        <p>Beachten Sie, dass das Reflog <span class="emphasis"><em>nur</em></span> lokal vorliegt und somit
nicht zum Repository gehört. Wenn Sie einem anderen Entwickler eine
Commit-ID oder einen Tag-Namen schicken, dann referenziert dies den
gleichen Commit – ein <code class="literal">master@{yesterday}</code> kann aber je nach
Entwickler <span class="emphasis"><em>verschiedene</em></span> Commits referenzieren.</p>
        <div class="tip" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Tipp</h3>
          <p>Wenn Sie keinen Branch und keinen Zeitpunkt angeben, nimmt Git <code class="literal">HEAD</code> an.
Somit können Sie in Kommandos <code class="literal">@</code> als Kurzform für <code class="literal">HEAD</code> verwenden.
Weiterhin verstehen viele Kommandos das Argument <code class="literal">-</code> als <code class="literal">@{-1}</code>, also
„letzte Position des <code class="literal">HEAD</code>“:</p>
          <pre class="screen">$ <span class="strong"><strong>git checkout feature</strong></span>   # vorher auf "master"
$ <span class="strong"><strong>git commit ...</strong></span>         # Änderungen, Commits machen
$ <span class="strong"><strong>git checkout -</strong></span>         # zurück auf "master"
$ <span class="strong"><strong>git merge -</strong></span>            # Merge von "feature"</pre>
        </div>
      </div>
      <div class="footnotes">
        <br />
        <hr style="width:100; text-align:left;margin-left: 0" />
        <div id="ftn.idm45240359203264" class="footnote">
          <p><a href="#idm45240359203264" class="simpara"><sup class="simpara">[29] </sup></a>Das hindert Sie natürlich nicht, einen
  Branch auf einen Commit „irgendwo in der Mitte“ zu setzen,
  was auch sinnvoll sein kann.</p>
        </div>
        <div id="ftn.idm45240359162272" class="footnote">
          <p><a href="#idm45240359162272" class="simpara"><sup class="simpara">[30] </sup></a>Aufgrund der
Tatsache, dass bei einem Merge die Reihenfolge der direkten Vorfahren
gespeichert wird, ist es wichtig, immer vom kleineren <span class="emphasis"><em>in</em></span> den
größeren Branch zu mergen, also z.B. <code class="literal">topic</code> nach <code class="literal">master</code>. Wenn Sie
dann mit <code class="literal">master^^</code> Commits im Master-Branch untersuchen wollen,
landen Sie nicht auf einmal auf Commits aus dem Topic-Branch (siehe
auch <a class="xref" href="ch03.html#sec.merge" title="3.3. Branches zusammenführen: Merges">Abschnitt 3.3, „Branches zusammenführen: Merges“</a>).</p>
        </div>
        <div id="ftn.idm45240359083648" class="footnote">
          <p><a href="#idm45240359083648" class="simpara"><sup class="simpara">[31] </sup></a>Wie Git eine
Referenz auf Gültigkeit überprüft, können Sie bei Bedarf in der Man-Page
<code class="literal">git-check-ref-format(1)</code> nachlesen.</p>
        </div>
        <div id="ftn.idm45240359063760" class="footnote">
          <p><a href="#idm45240359063760" class="simpara"><sup class="simpara">[32] </sup></a>Wie lange sie dort verweilen, bestimmen Sie
  mit entsprechenden Einstellungen für die <span class="emphasis"><em>Garbage Collection</em></span>
  (Wartungsmechanismen), siehe <a class="xref" href="apb.html#sec.gc" title="B.1. Aufräumen">Abschnitt B.1, „Aufräumen“</a>.</p>
        </div>
        <div id="ftn.idm45240359049680" class="footnote">
          <p><a href="#idm45240359049680" class="simpara"><sup class="simpara">[33] </sup></a>Eine
  detaillierte Übersicht der Vor- und Nachteile der beiden Schemata
  sowie eine Beschreibung des Release-Prozesses usw.  finden Sie im
  Kapitel 6 des Buches <span class="emphasis"><em>Open Source Projektmanagement</em></span> von Michael
  Prokop (Open Source Press, München, 2010).</p>
        </div>
        <div id="ftn.idm45240358982096" class="footnote">
          <p><a href="#idm45240358982096" class="simpara"><sup class="simpara">[34] </sup></a>Um einen solchen getaggten Blob in ein
  Repository aufzunehmen, bedienen Sie sich des folgenden
  Kommandos: <code class="literal">git tag -am "&lt;beschreibung&gt;" &lt;tag-name&gt;
  $(git hash-object -w &lt;datei&gt;)</code>.</p>
        </div>
        <div id="ftn.idm45240358966896" class="footnote">
          <p><a href="#idm45240358966896" class="simpara"><sup class="simpara">[35] </sup></a>Es handelt sich hierbei um die
  Commits, die mit <code class="literal">git log v1.7.1..28ba96a</code> erfasst werden.</p>
        </div>
        <div id="ftn.idm45240358843888" class="footnote">
          <p><a href="#idm45240358843888" class="simpara"><sup class="simpara">[36] </sup></a>Um zu überprüfen, dass die Änderungen in
  Ihrem neuen Branch denen des alten entsprechen, verwenden Sie
  <code class="literal">git diff &lt;reorder-feature&gt; &lt;feature&gt;</code> – wenn das
  Kommando keine Ausgabe erzeugt, dann enthalten die Branches
  identische Änderungen.</p>
        </div>
        <div id="ftn.idm45240358822816" class="footnote">
          <p><a href="#idm45240358822816" class="simpara"><sup class="simpara">[37] </sup></a>Es ist nicht zwingend notwendig, dass
  eine Merge-Basis existiert; wenn Sie zum Beispiel mehrere
  Root-Commits in einem Repository verwalten (siehe auch
  <a class="xref" href="ch04.html#sec.multi-root" title="4.7. Mehrere Root-Commits">Abschnitt 4.7, „Mehrere Root-Commits“</a>) und dann die darauf aufgebauten
  Branches mergen, gibt es – sofern vorher noch kein Merge stattfand
  – keine gemeinsame Basis. In diesem Fall erzeugt eine Datei, die
  auf beiden Seiten in verschiedenen Versionen vorliegt, einen
  Konflikt.</p>
        </div>
        <div id="ftn.idm45240358816896" class="footnote">
          <p><a href="#idm45240358816896" class="simpara"><sup class="simpara">[38] </sup></a>Die
  nachfolgende Beschreibung erläutert die Vorgehensweise der
  <code class="literal">resolve</code>-Strategie. Sie unterscheidet sich nur wenig von der
  Standard-Strategie <code class="literal">recursive</code>, siehe auch die
  Detailbeschreibung dieser Strategie in <a class="xref" href="ch03.html#sec.merge-strategies" title="3.3.3. Merge-Strategien">Abschnitt 3.3.3, „Merge-Strategien“</a>.</p>
        </div>
        <div id="ftn.idm45240358746640" class="footnote">
          <p><a href="#idm45240358746640" class="simpara"><sup class="simpara">[39] </sup></a>Die
      <code class="literal">recursive</code>-Strategie geht also nur dann wesentlich
      intelligenter als <code class="literal">resolve</code> vor, wenn die
      <span class="emphasis"><em>Topologie</em></span> der Commits (d.h. die Anordnung, wo
      abgezweigt und zusammengeführt wurde) wesentlich komplizierter
      ist als ein bloßes Abzweigen und anschließendes Zusammenführen.</p>
        </div>
        <div id="ftn.idm45240358670032" class="footnote">
          <p><a href="#idm45240358670032" class="simpara"><sup class="simpara">[40] </sup></a>Die für den Merge relevanten Commits,
  die etwas an der Datei <code class="literal">output.c</code> geändert haben, kann
  Beatrice mit <code class="literal">git log --merge -p -- output.c</code> auflisten.</p>
        </div>
        <div id="ftn.idm45240358627568" class="footnote">
          <p>
            <a href="#idm45240358627568" class="simpara">
              <sup class="simpara">[41] </sup>
            </a>
            <a class="ulink" href="http://kdiff3.sourceforge.net/" target="_top">http://kdiff3.sourceforge.net/</a>
          </p>
        </div>
        <div id="ftn.idm45240358626304" class="footnote">
          <p>
            <a href="#idm45240358626304" class="simpara">
              <sup class="simpara">[42] </sup>
            </a>
            <a class="ulink" href="http://meld.sourceforge.net/" target="_top">http://meld.sourceforge.net/</a>
          </p>
        </div>
        <div id="ftn.idm45240358620736" class="footnote">
          <p><a href="#idm45240358620736" class="simpara"><sup class="simpara">[43] </sup></a>In Vimdiff können Sie mit
  <code class="literal">Strg+W</code> und anschließender Bewegung mit den Pfeiltasten oder
  <code class="literal">h</code>, <code class="literal">j</code>, <code class="literal">k</code>, <code class="literal">l</code> das Fenster in die
  entsprechende Richtung wechseln. Mit <code class="literal">dp</code> bzw.  <code class="literal">do</code>
  schieben Sie Änderungen auf die andere Seite oder übernehmen sie von
  dort (<span class="emphasis"><em>diff put</em></span> – <span class="emphasis"><em>diff obtain</em></span>).</p>
        </div>
        <div id="ftn.idm45240358581552" class="footnote">
          <p><a href="#idm45240358581552" class="simpara"><sup class="simpara">[44] </sup></a>Die Meldung <code class="literal">Automatic
    merge failed</code> bedeutet lediglich, dass ein Konflikt auftrat, der
  <span class="emphasis"><em>nicht</em></span> durch einen 3-Wege-Merge gelöst werden konnte. Da
  Rerere keine sinnvolle Lösung garantieren kann, wird die Lösung nur
  „bereitgestellt“, nicht aber als ultimative Lösung des
  Konflikts angesehen.</p>
        </div>
        <div id="ftn.idm45240358554480" class="footnote">
          <p><a href="#idm45240358554480" class="simpara"><sup class="simpara">[45] </sup></a>Weitere nützliche Tipps finden
  Sie in <a class="xref" href="ch06.html" title="Kapitel 6. Workflows">Kapitel 6, <em>Workflows</em></a>.</p>
        </div>
        <div id="ftn.idm45240358551184" class="footnote">
          <p><a href="#idm45240358551184" class="simpara"><sup class="simpara">[46] </sup></a>AsciiDoc ist eine simple,
  wiki-ähnliche Markup-Sprache:
  <code class="literal">http://www.methods.co.nz/asciidoc/</code>. Die Git-Dokumentation liegt in
  diesem Format vor und wird in HTML-Seiten und Man-Pages konvertiert,
  und auch dieses Buch wurde in AsciiDoc geschrieben!</p>
        </div>
        <div id="ftn.idm45240358548864" class="footnote">
          <p><a href="#idm45240358548864" class="simpara"><sup class="simpara">[47] </sup></a>Das Repository des Git-Projekts
  selbst verwaltet zum Beispiel die autogenerierte HTML-Dokumentation
  in einem Branch <code class="literal">html</code>, der von den Entwicklungsbranches
  vollständig abgekoppelt ist. So kann es bei Merges zwischen den
  Code-Branches nicht zu Konflikten wegen unterschiedlich kompilierter
  HTML-Dokumentation kommen. Wie Sie solche „entkoppelten“
  Branches erstellen, beschreiben wir in <a class="xref" href="ch04.html#sec.multi-root" title="4.7. Mehrere Root-Commits">Abschnitt 4.7, „Mehrere Root-Commits“</a>.</p>
        </div>
        <div id="ftn.idm45240358537216" class="footnote">
          <p><a href="#idm45240358537216" class="simpara"><sup class="simpara">[48] </sup></a>Das liegt daran, dass das
  Merge-Kommando nicht jeden Commit einzeln untersucht. Stattdessen
  werden drei Trees verglichen, in denen <span class="emphasis"><em>unter anderen</em></span> diese
  Änderungen enthalten sind, siehe <a class="xref" href="ch03.html#sec.merge-detail" title="3.3.1. Zwei Branches verschmelzen">Abschnitt 3.3.1, „Zwei Branches verschmelzen“</a>.</p>
        </div>
        <div id="ftn.idm45240358533344" class="footnote">
          <p><a href="#idm45240358533344" class="simpara"><sup class="simpara">[49] </sup></a>Das liegt daran, dass Rebase intern
  mit <code class="literal">cherry-pick</code> arbeitet, was wiederum erkennt, wenn die
  Änderungen, die durch den Commit eingebracht würden, schon vorhanden
  sind. Eine ähnliche Funktionalität bietet auch <code class="literal">git cherry</code>
  bzw. <code class="literal">git patch-id</code>, das fast gleiche Patches erkennen kann.</p>
        </div>
        <div id="ftn.idm45240358487792" class="footnote">
          <p><a href="#idm45240358487792" class="simpara"><sup class="simpara">[50] </sup></a>Möglicherweise besitzt das Zeichen <code class="literal">^</code> in
Ihrer Shell eine besondere Bedeutung (dies ist z.B.  in der Z-Shell
oder rc-Shell der Fall). Dann müssen Sie das Zeichen maskieren, also
das Argument in Anführungszeichen einfassen oder einen Backslash
voranstellen. In der Z-Shell existiert außerdem das Kommando <code class="literal">noglob</code>,
das Sie <code class="literal">git</code> voranstellen, um die Sonderbedeutung von <code class="literal">^</code>
aufzuheben.</p>
        </div>
        <div id="ftn.idm45240358453040" class="footnote">
          <p><a href="#idm45240358453040" class="simpara"><sup class="simpara">[51] </sup></a>Dies ist nicht nötigerweise ein Commit – das können auch Tags oder Blobs sein.</p>
        </div>
        <div id="ftn.idm45240358403344" class="footnote">
          <p><a href="#idm45240358403344" class="simpara"><sup class="simpara">[52] </sup></a>Ob die Commits nicht schon aufgrund
  ihres Alters herausgefallen sind, hängt natürlich davon ab, wie oft
  Sie eine <span class="emphasis"><em>Garbage-Collection</em></span> per <code class="literal">git gc</code> durchführen.
  Siehe auch <a class="xref" href="apb.html#sec.gc" title="B.1. Aufräumen">Abschnitt B.1, „Aufräumen“</a>.
</p>
        </div>
        <div id="ftn.idm45240358390608" class="footnote">
          <p><a href="#idm45240358390608" class="simpara"><sup class="simpara">[53] </sup></a>Wollen
  Sie alle Commits der letzten zwei Wochen auflisten, verwenden Sie
  stattdessen <code class="literal">git log --since='two weeks ago'</code>.</p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="ch02.html">Zurück</a> </td>
          <td width="20%" align="center"> </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch04.html">Weiter</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top"> </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Zum Anfang</a>
          </td>
          <td width="40%" align="right" valign="top"> </td>
        </tr>
      </table>
    </div>
    <div xmlns="" class="cc-license">
      <hr />
      <p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />Lizensiert unter der <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </p>
    </div>
  </body>
</html>
